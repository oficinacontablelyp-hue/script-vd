local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Servicios de Roblox
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local LP = Players.LocalPlayer

-- Tablas de caché para optimización
local cache = {
    players = {},
    generators = {},
    highlights = {},
    billboards = {}
}

-- Variables de rendimiento
local PERFORMANCE = {
    MAX_PLAYERS = 20, -- Límite de jugadores para ESP
    MAX_DISTANCE = 300, -- Distancia máxima de renderizado
    UPDATE_INTERVAL = 0.25, -- Intervalo de actualización (reducido de 0.12)
    FRAME_SKIP = 2, -- Saltar frames para más rendimiento
    BATCH_SIZE = 3, -- Procesar jugadores en lotes
    frameCounter = 0
}

-- Funciones auxiliares optimizadas
local function alive(obj)
    return obj and obj.Parent ~= nil
end

local function validPart(p)
    return p and p:IsA("BasePart") and alive(p)
end

local function dist(a, b)
    return (a - b).Magnitude
end

-- Función de primer BasePart optimizada
local function firstBasePart(inst)
    if not alive(inst) then return nil end
    
    if inst:IsA("BasePart") then
        return inst
    elseif inst:IsA("Model") then
        local primary = inst.PrimaryPart
        if primary and primary:IsA("BasePart") and alive(primary) then
            return primary
        end
        return inst:FindFirstChildWhichIsA("BasePart", true)
    end
    return nil
end

-- Billboard optimizado (reutilizado)
local function makeBillboard(text, color3, parent)
    if cache.billboards[parent] then
        local label = cache.billboards[parent]:FindFirstChild("Label")
        if label then
            label.Text = text
            label.TextColor3 = color3
        end
        return cache.billboards[parent]
    end
    
    local g = Instance.new("BillboardGui")
    g.Name = "VD_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 200, 0, 36)
    g.StudsOffset = Vector3.new(0, 3, 0)
    g.MaxDistance = PERFORMANCE.MAX_DISTANCE
    g.Enabled = true
    
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1, 1, 1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0, 0, 0)
    l.Parent = g
    
    cache.billboards[parent] = g
    return g
end

-- Highlight optimizado (reutilizado)
local function ensureHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return end
    
    local hl = cache.highlights[model]
    if not hl then
        local ok, result = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "VD_HL"
            h.Adornee = model
            h.FillTransparency = 0.5
            h.OutlineTransparency = 0.2
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.FillColor = color
            h.OutlineColor = color
            h.Parent = model
            return h
        end)
        
        if ok then
            cache.highlights[model] = result
            hl = result
        else
            return nil
        end
    end
    
    hl.FillColor = color
    hl.OutlineColor = color
    return hl
end

-- Crear ventana
local Window = Rayfield:CreateWindow({
    Name = "LoreOnTop - OPTIMIZADO",
    LoadingTitle = "Violence District",
    LoadingSubtitle = "by Lore (Optimizado)",
    ConfigurationSaving = {Enabled = true, FolderName = "ESP_Suite", FileName = "esp_config"},
    KeySystem = false,
    Discord = {
        Enabled = false,
    }
})

-- VISUAL TAB
local VisualTab = Window:CreateTab("Visual")
VisualTab:CreateSection("ESP (Optimizado)")

-- Variables Player ESP
local survivorColor = Color3.fromRGB(0, 255, 0)
local killerColor = Color3.fromRGB(255, 0, 0)
local spectatorColor = Color3.fromRGB(255, 255, 255)

local playerESPEnabled = false
local nametagsEnabled = false
local showDistance = true
local highlightFillTransparency = 0.5
local highlightOutlineTransparency = 0.2
local textTransparency = 0.0

-- Sistema de actualización optimizado
local updateQueue = {}
local processingBatch = false
local lastUpdate = 0

-- Función para determinar rol optimizada
local function getRole(p)
    local team = p.Team
    if team then
        local teamName = team.Name:lower()
        if teamName:find("killer") then
            return "Killer"
        elseif teamName:find("survivor") then
            return "Survivor"
        end
    end
    return "Survivor"
end

-- Función para verificar espectador optimizada
local function isSpectator(p)
    if not p or not p.Character then return true end
    
    local hum = p.Character:FindFirstChildOfClass("Humanoid")
    if hum and hum.Health <= 0 then return true end
    
    return p:GetAttribute("Spectator") == true
end

-- Aplicar ESP a un jugador (optimizado)
local function applyOnePlayerESP(p)
    if p == LP then return end
    
    local char = p.Character
    if not char or not alive(char) then
        -- Limpiar si el personaje no existe
        if cache.highlights[char] then
            cache.highlights[char]:Destroy()
            cache.highlights[char] = nil
        end
        if cache.billboards[char] then
            cache.billboards[char]:Destroy()
            cache.billboards[char] = nil
        end
        return
    end
    
    -- Verificar distancia (optimización crítica)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local myHrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
    
    if hrp and myHrp then
        local distance = (hrp.Position - myHrp.Position).Magnitude
        if distance > PERFORMANCE.MAX_DISTANCE then
            -- Deshabilitar ESP para jugadores lejanos
            if cache.highlights[char] then
                cache.highlights[char].Enabled = false
            end
            if cache.billboards[char] then
                local bb = cache.billboards[char]
                if bb.Parent then
                    bb.Enabled = false
                end
            end
            return
        end
    end
    
    -- Determinar color
    local color
    if isSpectator(p) then
        color = spectatorColor
    else
        local role = getRole(p)
        color = role == "Killer" and killerColor or survivorColor
    end
    
    -- Aplicar Highlight (si está habilitado)
    if playerESPEnabled then
        local hl = ensureHighlight(char, color)
        if hl then
            hl.Enabled = true
            hl.FillTransparency = highlightFillTransparency
            hl.OutlineTransparency = highlightOutlineTransparency
        end
    elseif cache.highlights[char] then
        cache.highlights[char].Enabled = false
    end
    
    -- Aplicar Nametag (si está habilitado)
    local head = char:FindFirstChild("Head")
    if head and nametagsEnabled then
        local tagText = p.Name
        
        if showDistance and hrp and myHrp and not isSpectator(p) then
            local distance = math.floor((hrp.Position - myHrp.Position).Magnitude)
            tagText = tagText .. " - " .. distance .. "m"
        end
        
        local bb = makeBillboard(tagText, color, head)
        if bb then
            bb.Parent = head
            bb.Enabled = true
            
            local label = bb:FindFirstChild("Label")
            if label then
                label.TextTransparency = textTransparency
                label.TextStrokeTransparency = textTransparency
            end
        end
    elseif head and cache.billboards[head] then
        cache.billboards[head].Enabled = false
    end
end

-- Sistema de procesamiento por lotes optimizado
local function processPlayerBatch()
    if processingBatch or not playerESPEnabled and not nametagsEnabled then return end
    if #updateQueue == 0 then return end
    
    processingBatch = true
    local processed = 0
    
    for i = 1, math.min(PERFORMANCE.BATCH_SIZE, #updateQueue) do
        local player = table.remove(updateQueue, 1)
        if player and player.Parent then
            applyOnePlayerESP(player)
            processed = processed + 1
        end
    end
    
    processingBatch = false
    return processed
end

-- Loop principal optimizado
local espLoopConn = nil
local function startESPLoop()
    if espLoopConn then return end
    
    espLoopConn = RunService.Heartbeat:Connect(function(deltaTime)
        PERFORMANCE.frameCounter = PERFORMANCE.frameCounter + 1
        
        -- Saltar frames para más rendimiento
        if PERFORMANCE.frameCounter % PERFORMANCE.FRAME_SKIP ~= 0 then return end
        
        -- Control de intervalo de actualización
        local now = tick()
        if now - lastUpdate < PERFORMANCE.UPDATE_INTERVAL then return end
        lastUpdate = now
        
        -- Limpiar cola y agregar jugadores
        updateQueue = {}
        local players = Players:GetPlayers()
        local count = 0
        
        for _, player in ipairs(players) do
            if player ~= LP and count < PERFORMANCE.MAX_PLAYERS then
                table.insert(updateQueue, player)
                count = count + 1
            end
        end
        
        -- Procesar lote
        processPlayerBatch()
    end)
end

local function stopESPLoop()
    if espLoopConn then
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    -- Limpiar todos los ESP
    for model, hl in pairs(cache.highlights) do
        if hl then
            hl:Destroy()
        end
    end
    
    for parent, bb in pairs(cache.billboards) do
        if bb then
            bb:Destroy()
        end
    end
    
    cache.highlights = {}
    cache.billboards = {}
    updateQueue = {}
end

-- Observadores de jugadores optimizados
local playerConnections = {}
local function watchPlayer(player)
    if playerConnections[player] then return end
    
    playerConnections[player] = {
        player.CharacterAdded:Connect(function(char)
            task.wait(0.5) -- Esperar a que el personaje cargue completamente
            if playerESPEnabled or nametagsEnabled then
                table.insert(updateQueue, player)
            end
        end),
        
        player:GetPropertyChangedSignal("Team"):Connect(function()
            if playerESPEnabled or nametagsEnabled then
                table.insert(updateQueue, player)
            end
        end)
    }
    
    if player.Character then
        table.insert(updateQueue, player)
    end
end

local function unwatchPlayer(player)
    if playerConnections[player] then
        for _, conn in ipairs(playerConnections[player]) do
            conn:Disconnect()
        end
        playerConnections[player] = nil
    end
    
    -- Limpiar ESP del jugador
    if player.Character then
        local char = player.Character
        if cache.highlights[char] then
            cache.highlights[char]:Destroy()
            cache.highlights[char] = nil
        end
        if char:FindFirstChild("Head") then
            local head = char.Head
            if cache.billboards[head] then
                cache.billboards[head]:Destroy()
                cache.billboards[head] = nil
            end
        end
    end
end

-- Toggles Player ESP
VisualTab:CreateToggle({
    Name = "Players ESP",
    CurrentValue = false,
    Flag = "PlayerESP",
    Callback = function(state)
        playerESPEnabled = state
        if state or nametagsEnabled then
            startESPLoop()
        else
            stopESPLoop()
        end
    end
})

VisualTab:CreateToggle({
    Name = "Names/Distance",
    CurrentValue = false,
    Flag = "Nametags",
    Callback = function(state)
        nametagsEnabled = state
        if state or playerESPEnabled then
            startESPLoop()
        else
            stopESPLoop()
        end
    end
})

-- Configuraciones de color
VisualTab:CreateColorPicker({
    Name = "Survivor Color",
    Color = survivorColor,
    Flag = "SurvivorCol",
    Callback = function(color)
        survivorColor = color
    end
})

VisualTab:CreateColorPicker({
    Name = "Killer Color",
    Color = killerColor,
    Flag = "KillerCol",
    Callback = function(color)
        killerColor = color
    end
})

-- Configuraciones de transparencia
VisualTab:CreateSlider({
    Name = "Player Transparency",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = highlightFillTransparency,
    Flag = "FillTrans",
    Callback = function(value)
        highlightFillTransparency = value
    end
})

VisualTab:CreateSlider({
    Name = "Outline Transparency",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = highlightOutlineTransparency,
    Flag = "OutlineTrans",
    Callback = function(value)
        highlightOutlineTransparency = value
    end
})

VisualTab:CreateSlider({
    Name = "Text Transparency",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = textTransparency,
    Flag = "TextTrans",
    Callback = function(value)
        textTransparency = value
    end
})

VisualTab:CreateSlider({
    Name = "Distancia Máxima ESP",
    Range = {50, 1000},
    Increment = 10,
    Suffix = " studs",
    CurrentValue = PERFORMANCE.MAX_DISTANCE,
    Flag = "MaxDistance",
    Callback = function(value)
        PERFORMANCE.MAX_DISTANCE = value
    end
})

-- Inicializar observadores
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LP then
        watchPlayer(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LP then
        watchPlayer(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    unwatchPlayer(player)
end)

-- GENERATOR ESP OPTIMIZADO
VisualTab:CreateSection("Generators")

local generatorESPEnabled = false
local generatorColor = Color3.fromRGB(0, 170, 255)
local generators = {}
local generatorLoop = nil

-- Sistema de generadores optimizado
local function registerGenerator(gen)
    if not gen or generators[gen] then return end
    
    local primary = firstBasePart(gen)
    if not primary then return end
    
    generators[gen] = {
        model = gen,
        part = primary,
        highlight = nil,
        billboard = nil,
        lastUpdate = 0
    }
end

local function unregisterGenerator(gen)
    if generators[gen] then
        local data = generators[gen]
        if data.highlight then
            data.highlight:Destroy()
        end
        if data.billboard then
            data.billboard:Destroy()
        end
        generators[gen] = nil
    end
end

-- Buscar generadores optimizado
local function findGenerators()
    for _, map in ipairs({Workspace:FindFirstChild("Map"), Workspace:FindFirstChild("Map1")}) do
        if map then
            for _, obj in ipairs(map:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == "Generator" then
                    registerGenerator(obj)
                end
            end
        end
    end
end

-- Actualizar generador optimizado
local function updateGenerator(gen, data)
    local now = tick()
    if now - data.lastUpdate < 1 then return end
    data.lastUpdate = now
    
    if not generatorESPEnabled or not alive(gen) then
        if data.highlight then
            data.highlight.Enabled = false
        end
        if data.billboard then
            data.billboard.Enabled = false
        end
        return
    end
    
    -- Verificar distancia
    local myHrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
    if myHrp and data.part then
        local distance = (data.part.Position - myHrp.Position).Magnitude
        if distance > PERFORMANCE.MAX_DISTANCE then
            if data.highlight then
                data.highlight.Enabled = false
            end
            if data.billboard then
                data.billboard.Enabled = false
            end
            return
        end
    end
    
    -- Obtener progreso
    local progress = tonumber(gen:GetAttribute("RepairProgress")) or 0
    local percentage = math.floor(math.clamp(progress * 100, 0, 100))
    
    -- Aplicar highlight
    if not data.highlight then
        data.highlight = ensureHighlight(gen, generatorColor)
    end
    if data.highlight then
        data.highlight.Enabled = true
        data.highlight.FillTransparency = 0.7
        data.highlight.OutlineTransparency = 0.3
    end
    
    -- Aplicar billboard
    if not data.billboard then
        data.billboard = makeBillboard("Gen " .. percentage .. "%", generatorColor, data.part)
    end
    if data.billboard then
        data.billboard.Parent = data.part
        data.billboard.Enabled = true
        
        local label = data.billboard:FindFirstChild("Label")
        if label then
            label.Text = "Gen " .. percentage .. "%"
            label.TextColor3 = Color3.fromRGB(
                math.floor(255 * (1 - progress)),
                math.floor(255 * progress),
                0
            )
        end
    end
end

-- Loop de generadores optimizado
local function startGeneratorLoop()
    if generatorLoop then return end
    
    generatorLoop = RunService.Heartbeat:Connect(function(deltaTime)
        PERFORMANCE.frameCounter = PERFORMANCE.frameCounter + 1
        if PERFORMANCE.frameCounter % (PERFORMANCE.FRAME_SKIP * 2) ~= 0 then return end
        
        for gen, data in pairs(generators) do
            updateGenerator(gen, data)
        end
    end)
end

local function stopGeneratorLoop()
    if generatorLoop then
        generatorLoop:Disconnect()
        generatorLoop = nil
    end
    
    for gen, data in pairs(generators) do
        unregisterGenerator(gen)
    end
end

-- Inicializar generadores
task.spawn(function()
    task.wait(3) -- Esperar a que el juego cargue
    findGenerators()
end)

-- Toggle Generator ESP
VisualTab:CreateToggle({
    Name = "Generator ESP",
    CurrentValue = false,
    Flag = "GeneratorESP",
    Callback = function(state)
        generatorESPEnabled = state
        if state then
            startGeneratorLoop()
        else
            stopGeneratorLoop()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Generator Color",
    Color = generatorColor,
    Flag = "GenCol",
    Callback = function(color)
        generatorColor = color
    end
})

-- SURVIVORS TAB (Generator Boost / Speed / Skillcheck)
local SurvivorTab = Window:CreateTab("Survivors")
SurvivorTab:CreateSection("Generator")

local genBoostEnabled = false
local genBoostValue = 1.25
local repairingGenerator = nil
local repairWatcher = nil
local appliedBoosts = {}
local lastGeneratorCheck = 0
local GENERATOR_CHECK_INTERVAL = 0.3 -- Verificar generadores cada 0.3 segundos

-- Función optimizada para detectar generador cercano
local function detectGeneratorNearby(range)
    if tick() - lastGeneratorCheck < GENERATOR_CHECK_INTERVAL then
        return repairingGenerator
    end
    lastGeneratorCheck = tick()
    
    local char = LP.Character
    if not char then return nil end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closest = nil
    local closestDist = range or 10
    
    -- Usar la caché de generadores ya registrada
    for gen, data in pairs(generators) do
        if data and data.part and alive(gen) then
            local distance = (data.part.Position - hrp.Position).Magnitude
            if distance < closestDist then
                closestDist = distance
                closest = gen
            end
        end
    end
    
    return closest
end

-- Aplicar boost optimizado (una sola vez)
local function applyGenBoost(gen)
    if not gen or not genBoostEnabled or appliedBoosts[gen] then return end
    
    local success = pcall(function()
        -- Buscar solo valores específicos
        local repairValue = gen:FindFirstChild("RepairProgress") or gen:FindFirstChild("RepairValue")
        if repairValue and (repairValue:IsA("NumberValue") or repairValue:IsA("IntValue")) then
            appliedBoosts[gen] = {
                original = repairValue.Value,
                object = repairValue
            }
            repairValue.Value = repairValue.Value * genBoostValue
        end
    end)
    
    if not success then
        appliedBoosts[gen] = nil
    end
end

-- Remover boost optimizado
local function removeGenBoost(gen)
    if not gen or not appliedBoosts[gen] then return end
    
    local data = appliedBoosts[gen]
    pcall(function()
        if data.object and data.object.Parent then
            data.object.Value = data.original
        end
    end)
    
    appliedBoosts[gen] = nil
end

-- Watcher optimizado con intervalos
local function startRepairWatcher()
    if repairWatcher then return end
    
    repairWatcher = RunService.Heartbeat:Connect(function(deltaTime)
        if not genBoostEnabled then return end
        
        -- Verificar cada 0.3 segundos
        if tick() - lastGeneratorCheck < GENERATOR_CHECK_INTERVAL then return end
        
        local gen = detectGeneratorNearby(10)
        
        if gen ~= repairingGenerator then
            if repairingGenerator then
                removeGenBoost(repairingGenerator)
            end
            repairingGenerator = gen
            if gen then
                applyGenBoost(gen)
            end
        end
    end)
end

local function stopRepairWatcher()
    if repairWatcher then
        repairWatcher:Disconnect()
        repairWatcher = nil
    end
    
    if repairingGenerator then
        removeGenBoost(repairingGenerator)
        repairingGenerator = nil
    end
    
    -- Limpiar todos los boosts
    for gen in pairs(appliedBoosts) do
        removeGenBoost(gen)
    end
    appliedBoosts = {}
end

SurvivorTab:CreateToggle({
    Name = "Generator Boost",
    CurrentValue = false,
    Flag = "GenBoostToggle",
    Callback = function(state)
        genBoostEnabled = state
        if state then
            startRepairWatcher()
        else
            stopRepairWatcher()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Repair Multiplier",
    Range = {1.00, 2.00},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = genBoostValue,
    Flag = "GenBoostValue",
    Callback = function(v)
        genBoostValue = v
        -- Reaplicar boost si está activo
        if genBoostEnabled and repairingGenerator then
            removeGenBoost(repairingGenerator)
            applyGenBoost(repairingGenerator)
        end
    end
})

-- Speed Boost section optimizado
SurvivorTab:CreateSection("Speed Boost")

local speedBoostEnabled = false
local speedBoostValue = 1.25
local speedConnection = nil
local DEFAULT_WALKSPEED = 16

-- Función optimizada para aplicar speed boost
local function applySpeedBoost()
    if not speedBoostEnabled then return end
    
    local char = LP.Character
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            humanoid.WalkSpeed = DEFAULT_WALKSPEED * speedBoostValue
        end)
    end
end

-- Función para remover speed boost
local function removeSpeedBoost()
    local char = LP.Character
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            humanoid.WalkSpeed = DEFAULT_WALKSPEED
        end)
    end
end

-- Sistema optimizado de speed boost
local function setupSpeedBoost()
    if speedConnection then
        speedConnection:Disconnect()
    end
    
    if speedBoostEnabled then
        -- Aplicar al personaje actual
        applySpeedBoost()
        
        -- Conectar para cambios de personaje
        speedConnection = LP.CharacterAdded:Connect(function(char)
            task.wait(0.5) -- Esperar a que el personaje cargue
            if speedBoostEnabled then
                applySpeedBoost()
            end
        end)
    else
        removeSpeedBoost()
    end
end

SurvivorTab:CreateToggle({
    Name = "Speed Boost",
    CurrentValue = false,
    Flag = "SpeedBoostToggle",
    Callback = function(state)
        speedBoostEnabled = state
        setupSpeedBoost()
    end
})

SurvivorTab:CreateSlider({
    Name = "Speed Multiplier",
    Range = {1.00, 2.00},
    Increment = 0.10,
    Suffix = "x",
    CurrentValue = speedBoostValue,
    Flag = "SpeedBoostValue",
    Callback = function(v)
        speedBoostValue = v
        if speedBoostEnabled then
            applySpeedBoost()
        end
    end
})

-- SkillCheck Gen (Perfect)
SurvivorTab:CreateSection("SkillCheck Gen")

local perfectEnabled = false
local perfectConn = nil
local lastSkillCheck = 0
local SKILLCHECK_INTERVAL = 0.1 -- Verificar cada 0.1 segundos

-- Función optimizada para encontrar elementos de skillcheck
local function findSkillcheckElements()
    local pg = LP:FindFirstChild("PlayerGui")
    if not pg then return nil, nil, nil end
    
    -- Buscar solo en GUIs activas recientemente
    for _, gui in ipairs(pg:GetChildren()) do
        if gui:IsA("ScreenGui") and gui.Enabled then
            local bar = gui:FindFirstChild("SkillCheckBar", true) or 
                       gui:FindFirstChild("Bar", true) or
                       gui:FindFirstChild("ProgressBar", true)
            
            if bar and bar:IsA("Frame") then
                local zone = bar:FindFirstChild("PerfectZone") or 
                            bar:FindFirstChild("HitZone") or
                            bar:FindFirstChild("Zone")
                
                local pointer = bar:FindFirstChild("Pointer") or 
                               bar:FindFirstChild("Indicator") or
                               bar:FindFirstChild("Marker")
                
                if zone and pointer then
                    return bar, zone, pointer
                end
            end
        end
    end
    
    return nil, nil, nil
end

-- Loop optimizado para perfect skillcheck
local function enablePerfectLoop()
    if perfectConn then return end
    
    perfectConn = RunService.Heartbeat:Connect(function(deltaTime)
        if not perfectEnabled then return end
        
        -- Verificar cada 0.1 segundos
        local now = tick()
        if now - lastSkillCheck < SKILLCHECK_INTERVAL then return end
        lastSkillCheck = now
        
        local bar, zone, pointer = findSkillcheckElements()
        if bar and zone and pointer then
            pcall(function()
                -- Calcular posición del centro de la zona perfecta
                local zoneCenter = zone.AbsolutePosition.X + (zone.AbsoluteSize.X / 2)
                local barStart = bar.AbsolutePosition.X
                local barWidth = bar.AbsoluteSize.X
                
                if barWidth > 0 then
                    local percentage = (zoneCenter - barStart) / barWidth
                    percentage = math.clamp(percentage, 0, 1)
                    
                    -- Aplicar posición optimizada
                    if pointer:IsA("GuiObject") then
                        pointer.Position = UDim2.new(percentage, 0, pointer.Position.Y.Scale, pointer.Position.Y.Offset)
                    end
                end
            end)
        end
    end)
end

local function disablePerfectLoop()
    if perfectConn then
        perfectConn:Disconnect()
        perfectConn = nil
    end
end

SurvivorTab:CreateToggle({
    Name = "Perfect Skillcheck",
    CurrentValue = false,
    Callback = function(v)
        perfectEnabled = v
        if v then 
            enablePerfectLoop() 
        else 
            disablePerfectLoop() 
        end
    end
})

-- No SkillCheck Gen - OPTIMIZADO
SurvivorTab:CreateSection("No SkillCheck Gen")
local noSkillEnabled = false
local noSkillConn = nil
local skillcheckCache = {}

-- Lista de nombres de skillchecks para verificación rápida
local SKILLCHECK_NAMES = {
    "SkillCheck",
    "Skillcheck",
    "QuickTime",
    "QTE",
    "ButtonMash",
    "TimedPress"
}

-- Función optimizada para verificar si es skillcheck
local function isSkillObject(obj)
    if not obj or not obj.Name then return false end
    
    local name = obj.Name:lower()
    for _, skillName in ipairs(SKILLCHECK_NAMES) do
        if name:find(skillName:lower(), 1, true) then
            return true
        end
    end
    
    return false
end

-- Función para eliminar skillcheck
local function removeSkillObject(obj)
    if obj and (obj:IsA("GuiObject") or obj:IsA("ScreenGui")) then
        pcall(function()
            obj:Destroy()
        end)
        return true
    end
    return false
end

-- Sistema optimizado de no skillchecks
local function startNoSkill()
    if noSkillEnabled then return end
    noSkillEnabled = true
    
    local pg = LP:FindFirstChild("PlayerGui")
    if not pg then return end
    
    -- Limpiar cache
    skillcheckCache = {}
    
    -- Eliminar existentes
    for _, gui in ipairs(pg:GetChildren()) do
        if isSkillObject(gui) then
            if removeSkillObject(gui) then
                table.insert(skillcheckCache, gui)
            end
        end
    end
    
    -- Conectar para nuevos
    if noSkillConn then
        noSkillConn:Disconnect()
    end
    
    noSkillConn = pg.DescendantAdded:Connect(function(descendant)
        if noSkillEnabled and isSkillObject(descendant) then
            removeSkillObject(descendant)
        end
    end)
end

local function stopNoSkill()
    noSkillEnabled = false
    
    if noSkillConn then
        noSkillConn:Disconnect()
        noSkillConn = nil
    end
    
    skillcheckCache = {}
end

SurvivorTab:CreateToggle({
    Name = "No Skillchecks",
    CurrentValue = false,
    Callback = function(v)
        if v then 
            startNoSkill() 
        else 
            stopNoSkill() 
        end
    end
})

-- KILLERS TAB (mantenido simple)
local KillerTab = Window:CreateTab("Killers")
KillerTab:CreateSection("Opciones Killer")

local killerSpeedEnabled = false
local killerSpeedValue = 1.3

KillerTab:CreateToggle({
    Name = "Boost de Velocidad",
    CurrentValue = false,
    Callback = function(v)
        killerSpeedEnabled = v
        if v then
            -- Aplicar lógica de speed boost para killer
            local char = LP.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    pcall(function()
                        humanoid.WalkSpeed = 16 * killerSpeedValue
                    end)
                end
            end
        else
            -- Restaurar velocidad normal
            local char = LP.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    pcall(function()
                        humanoid.WalkSpeed = 16
                    end)
                end
            end
        end
    end
})

KillerTab:CreateSlider({
    Name = "Multiplicador Velocidad",
    Range = {1.0, 2.0},
    Increment = 0.1,
    CurrentValue = killerSpeedValue,
    Callback = function(v)
        killerSpeedValue = v
        if killerSpeedEnabled then
            local char = LP.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    pcall(function()
                        humanoid.WalkSpeed = 16 * killerSpeedValue
                    end)
                end
            end
        end
    end
})

-- GRAPHICS TAB OPTIMIZADO
local GraphicsTab = Window:CreateTab("Graphics")
GraphicsTab:CreateSection("Optimización")

-- Sección No Fog optimizada
local nfActive = false
local nfConnections = {}
local nfProcessQueue = {}
local nfLastProcess = 0
local NF_PROCESS_INTERVAL = 0.5

-- Lista de objetos a eliminar optimizada
local FOG_OBJECTS = {
    "Fog",
    "Smoke",
    "Mist",
    "Cloud",
    "Atmosphere",
    "ParticleEmitter"
}

-- Función optimizada para verificar fog
local function isFogObject(obj)
    if not obj then return false end
    
    local name = obj.Name:lower()
    for _, fogName in ipairs(FOG_OBJECTS) do
        if name:find(fogName:lower(), 1, true) then
            return true
        end
    end
    
    return obj:IsA("ParticleEmitter") or 
           obj:IsA("Clouds") or 
           obj:IsA("Atmosphere") or
           obj:IsA("SunRaysEffect") or
           obj:IsA("BloomEffect") or
           obj:IsA("DepthOfFieldEffect")
end

-- Función optimizada para eliminar fog
local function removeFogObject(obj)
    if not obj or not obj.Parent then return end
    
    pcall(function()
        if obj:IsA("ParticleEmitter") then
            obj.Enabled = false
            obj.Rate = 0
        elseif obj:IsA("Clouds") or obj:IsA("Atmosphere") then
            obj:Destroy()
        elseif isFogObject(obj) then
            obj:Destroy()
        end
    end)
end

-- Procesamiento por lotes de fog
local function processFogQueue()
    if not nfActive then return end
    
    local now = tick()
    if now - nfLastProcess < NF_PROCESS_INTERVAL then return end
    nfLastProcess = now
    
    -- Procesar máximo 10 objetos por frame
    local processed = 0
    for i = 1, math.min(10, #nfProcessQueue) do
        local obj = table.remove(nfProcessQueue, 1)
        if obj then
            removeFogObject(obj)
            processed = processed + 1
        end
    end
end

-- Barrido inicial optimizado
local function initialFogSweep()
    local areas = {Workspace, Lighting}
    
    for _, area in ipairs(areas) do
        for _, obj in ipairs(area:GetDescendants()) do
            if isFogObject(obj) then
                table.insert(nfProcessQueue, obj)
            end
        end
    end
end

-- Habilitar No Fog optimizado
local function nfEnable()
    if nfActive then return end
    nfActive = true

    -- Barrido inicial
    initialFogSweep()

    -- Conectar eventos
    table.insert(nfConnections, Workspace.DescendantAdded:Connect(function(obj)
        if nfActive and isFogObject(obj) then
            table.insert(nfProcessQueue, obj)
        end
    end))

    table.insert(nfConnections, Lighting.DescendantAdded:Connect(function(obj)
        if nfActive and isFogObject(obj) then
            table.insert(nfProcessQueue, obj)
        end
    end))

    -- Iniciar loop de procesamiento
    table.insert(nfConnections, RunService.Heartbeat:Connect(function()
        processFogQueue()
    end))
end

-- Deshabilitar No Fog
local function nfDisable()
    if not nfActive then return end
    nfActive = false
    
    -- Desconectar todo
    for _, conn in ipairs(nfConnections) do
        pcall(function() conn:Disconnect() end)
    end
    nfConnections = {}
    nfProcessQueue = {}
end

GraphicsTab:CreateToggle({
    Name = "No Fog (Optimizado)",
    CurrentValue = false,
    Flag = "NoFog",
    Callback = function(v)
        if v then 
            nfEnable() 
        else 
            nfDisable() 
        end
    end
})

-- Sección No Shadows optimizada
local nsActive = false
local nsConnections = {}
local shadowCache = {}
local NS_UPDATE_INTERVAL = 1.0
local nsLastUpdate = 0

-- Función para deshabilitar sombras en una parte
local function disableShadowsOnPart(part)
    if not part or not part:IsA("BasePart") then return end
    
    if nsActive then
        shadowCache[part] = part.CastShadow
        pcall(function()
            part.CastShadow = false
        end)
    else
        if shadowCache[part] ~= nil then
            pcall(function()
                part.CastShadow = shadowCache[part]
            end)
            shadowCache[part] = nil
        end
    end
end

-- Habilitar No Shadows optimizado
local function nsEnable()
    if nsActive then return end
    nsActive = true
    
    -- Deshabilitar sombras globales
    pcall(function()
        Lighting.GlobalShadows = false
    end)
    
    -- Procesar partes existentes en lotes
    task.spawn(function()
        local parts = Workspace:GetDescendants()
        local batchSize = 50
        
        for i = 1, #parts, batchSize do
            if not nsActive then break end
            
            for j = i, math.min(i + batchSize - 1, #parts) do
                local part = parts[j]
                if part:IsA("BasePart") then
                    disableShadowsOnPart(part)
                end
            end
            
            task.wait(0.01) -- Pequeña pausa para no bloquear
        end
    end)
    
    -- Conectar para nuevas partes
    table.insert(nsConnections, Workspace.DescendantAdded:Connect(function(obj)
        if nsActive and obj:IsA("BasePart") then
            disableShadowsOnPart(obj)
        end
    end))
end

-- Deshabilitar No Shadows
local function nsDisable()
    if not nsActive then return end
    nsActive = false
    
    -- Restaurar sombras globales
    pcall(function()
        Lighting.GlobalShadows = true
    end)
    
    -- Restaurar sombras en partes
    for part, originalValue in pairs(shadowCache) do
        if part and part.Parent then
            pcall(function()
                part.CastShadow = originalValue
            end)
        end
    end
    
    shadowCache = {}
    
    -- Desconectar todo
    for _, conn in ipairs(nsConnections) do
        pcall(function() conn:Disconnect() end)
    end
    nsConnections = {}
end

GraphicsTab:CreateToggle({
    Name = "No Shadows (Optimizado)",
    CurrentValue = false,
    Flag = "NoShadows",
    Callback = function(v)
        if v then 
            nsEnable() 
        else 
            nsDisable() 
        end
    end
})

-- Sección de calidad gráfica
GraphicsTab:CreateSection("Calidad Gráfica")

local lowGraphicsEnabled = false

local function setLowGraphics()
    if not lowGraphicsEnabled then return end
    
    pcall(function()
        -- Reducir calidad de gráficos
        settings().Rendering.QualityLevel = 1
        settings().Rendering.MeshCacheSize = 10
        settings().Rendering.TextureCacheSize = 10
        
        -- Optimizar lighting
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 10000
        Lighting.OutdoorAmbient = Color3.new(0.5, 0.5, 0.5)
    end)
end

local function restoreGraphics()
    pcall(function()
        -- Restaurar valores por defecto
        settings().Rendering.QualityLevel = 10
        settings().Rendering.MeshCacheSize = 128
        settings().Rendering.TextureCacheSize = 128
        
        Lighting.GlobalShadows = true
        Lighting.FogEnd = 100000
    end)
end

GraphicsTab:CreateToggle({
    Name = "Bajo Consumo Gráfico",
    CurrentValue = false,
    Callback = function(v)
        lowGraphicsEnabled = v
        if v then
            setLowGraphics()
        else
            restoreGraphics()
        end
    end
})

-- MISCELLANEOUS TAB
local MiscTab = Window:CreateTab("Misc")
MiscTab:CreateSection("Utilidades")

local autoJoinEnabled = false
local autoJoinTeam = "Survivor"

MiscTab:CreateToggle({
    Name = "Auto Join Team",
    CurrentValue = false,
    Callback = function(v)
        autoJoinEnabled = v
        if v then
            -- Intentar unirse al equipo seleccionado
            local teams = game:GetService("Teams"):GetTeams()
            for _, team in ipairs(teams) do
                if team.Name:lower():find(autoJoinTeam:lower()) then
                    pcall(function()
                        LP.Team = team
                    end)
                    break
                end
            end
        end
    end
})

MiscTab:CreateDropdown({
    Name = "Seleccionar Equipo",
    Options = {"Survivor", "Killer"},
    CurrentOption = "Survivor",
    Callback = function(v)
        autoJoinTeam = v
        if autoJoinEnabled then
            local teams = game:GetService("Teams"):GetTeams()
            for _, team in ipairs(teams) do
                if team.Name:lower():find(v:lower()) then
                    pcall(function()
                        LP.Team = team
                    end)
                    break
                end
            end
        end
    end
})

MiscTab:CreateSection("Información")

local fpsLabel = MiscTab:CreateLabel("FPS: 60")
local pingLabel = MiscTab:CreateLabel("Ping: 50ms")
local playerCountLabel = MiscTab:CreateLabel("Jugadores: 0")

-- Actualizar estadísticas periódicamente
local statsConnection = RunService.Heartbeat:Connect(function()
    -- Actualizar FPS
    pcall(function()
        fpsLabel:SetText("FPS: " .. math.floor(1/RunService.RenderStepped:Wait()))
    end)
    
    -- Actualizar conteo de jugadores
    playerCountLabel:SetText("Jugadores: " .. #Players:GetPlayers())
end)

-- Función de cleanup al cerrar
local function cleanup()
    -- Desconectar todas las conexiones
    if espLoopConn then espLoopConn:Disconnect() end
    if generatorLoop then generatorLoop:Disconnect() end
    if repairWatcher then repairWatcher:Disconnect() end
    if perfectConn then perfectConn:Disconnect() end
    if speedConnection then speedConnection:Disconnect() end
    if noSkillConn then noSkillConn:Disconnect() end
    if statsConnection then statsConnection:Disconnect() end
    
    -- Limpiar No Fog
    nfDisable()
    
    -- Limpiar No Shadows
    nsDisable()
    
    -- Limpiar todos los ESP
    stopESPLoop()
    stopGeneratorLoop()
    
    -- Limpiar cache
    cache.highlights = {}
    cache.billboards = {}
    cache.players = {}
    cache.generators = {}
    
    -- Restaurar valores
    if LP.Character then
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            pcall(function()
                humanoid.WalkSpeed = 16
            end)
        end
    end
    
    -- Restaurar gráficos
    restoreGraphics()
end

-- Conectar cleanup
game:GetService("UserInputService").WindowFocusReleased:Connect(function()
    cleanup()
end)

game:GetService("CoreGui").ChildRemoved:Connect(function(child)
    if child.Name:find("Rayfield") then
        cleanup()
    end
end)

-- Cargar configuración y notificar
Rayfield:LoadConfiguration()
Rayfield:Notify({
    Title = "LoreOnTop - OPTIMIZADO",
    Content = "Script cargado con éxito.",
    Duration = 6,
    Image = "rbxassetid://4483345998"
})

-- Mostrar consejos de optimización
task.wait(2)
Rayfield:Notify({
    Title = "Consejos de Optimización",
    Content = "1. Reduce la distancia máxima del ESP\n2. Usa intervalos más largos\n3. Limita el número de jugadores",
    Duration = 8
})
