local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Servicios
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer

-- Colores
local survivorColor = Color3.fromRGB(0, 255, 0)
local killerColor = Color3.fromRGB(255, 0, 0)
local spectatorColor = Color3.fromRGB(255, 255, 255)
local lobbyColor = Color3.fromRGB(200, 200, 200)
local generatorColor = Color3.fromRGB(0, 170, 255)

-- Cache
local playerCache = {}
local connections = {}
local espObjects = {}

-- Funciones auxiliares
local function alive(obj)
    return obj and obj.Parent ~= nil
end

local function validPart(p)
    return p and p:IsA("BasePart") and alive(p)
end

local function dist(a, b)
    return (a - b).Magnitude
end

local function clamp(n, lo, hi)
    if n < lo then return lo elseif n > hi then return hi else return n end
end

local function firstBasePart(inst)
    if not alive(inst) then return nil end
    if inst:IsA("BasePart") then return inst end
    if inst:IsA("Model") then
        if inst.PrimaryPart and inst.PrimaryPart:IsA("BasePart") and alive(inst.PrimaryPart) then
            return inst.PrimaryPart
        end
        local p = inst:FindFirstChildWhichIsA("BasePart", true)
        if validPart(p) then return p end
    end
    return nil
end

-- Billboard
local function makeBillboard(text, color3, parent)
    if not parent then return nil end
    
    local existing = parent:FindFirstChild("ESP_Tag")
    if existing then
        local label = existing:FindFirstChild("Label")
        if label then
            label.Text = text
            label.TextColor3 = color3
        end
        existing.Enabled = true
        return existing
    end
    
    local g = Instance.new("BillboardGui")
    g.Name = "ESP_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 200, 0, 36)
    g.StudsOffset = Vector3.new(0, 3, 0)
    g.Enabled = true
    g.Parent = parent
    
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1, 1, 1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0, 0, 0)
    l.Parent = g
    
    table.insert(espObjects, g)
    
    return g
end

-- Highlight
local function ensureHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    local hl = model:FindFirstChild("ESP_Highlight")
    if not hl then
        local success, result = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "ESP_Highlight"
            h.Adornee = model
            h.FillTransparency = 0.5
            h.OutlineTransparency = 0.2
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.FillColor = color
            h.OutlineColor = color
            h.Parent = model
            return h
        end)
        if success then 
            hl = result
            table.insert(espObjects, hl)
        else 
            return nil 
        end
    else
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.5
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
    end
    return hl
end

local function clearHighlight(model)
    if model and model:FindFirstChild("ESP_Highlight") then
        local hl = model.ESP_Highlight
        hl:Destroy()
        for i, obj in ipairs(espObjects) do
            if obj == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

-- Función para obtener rol
local function getRole(p)
    if not p then return "Lobby" end
    local team = p.Team
    if not team then return "Lobby" end
    local teamName = team.Name:lower()
    if teamName:find("killer") then
        return "Killer"
    elseif teamName:find("survivor") then
        return "Survivor"
    end
    return "Lobby"
end

-- Función para verificar espectador
local function isSpectator(p)
    if not p then return true end
    if not p.Character then return true end
    
    local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return true end
    
    return p:GetAttribute("Spectator") == true
end

-- Función para determinar si está en lobby
local function isInLobby(p)
    if not p then return true end
    if not p.Character then return true end
    
    local hrp = p.Character:FindFirstChild("HumanoidRootPart")  
    if hrp then
        local pos = hrp.Position
        if pos.Y < -100 then
            return true
        end
    end
    
    return getRole(p) == "Lobby"
end

-- Función para obtener color
local function getPlayerColor(p)
    if isInLobby(p) then
        return lobbyColor
    elseif isSpectator(p) then
        return spectatorColor
    elseif getRole(p) == "Killer" then
        return killerColor
    else
      return survivorColor
    end
end

-- ============================================
-- SISTEMA ESP PARA JUGADORES
-- ============================================
local playerESPEnabled = false
local nametagsEnabled = false 
local espLoopConn = nil
local lastPlayerESPUpdate = 0
local PLAYER_ESP_INTERVAL = 1.5

local function cleanPlayerESP(p)
    if not p then return end
    
    if p.Character then
        clearHighlight(p.Character)
        local head = p.Character:FindFirstChild("Head")
        if head and head:FindFirstChild("ESP_Tag") then
            head.ESP_Tag:Destroy()
        end
    end
    
    if playerCache[p] then
        playerCache[p] = nil
    end
end

local function applyOptimizedPlayerESP(p)
    if p == LP then return end
    
    local character = p.Character
    if not (character and alive(character)) then
        cleanPlayerESP(p)
        return
    end
    
    local color = getPlayerColor(p)
    
    -- Determinar qué mostrar basado en el estado
    local isLobby = isInLobby(p)
    local isSpec = isSpectator(p)
    local showPlayer = playerESPEnabled and not isLobby and not isSpec
    local showName = nametagsEnabled
    
    -- Limpiar si no hay nada que mostrar
    if not (showPlayer or showName) then
        cleanPlayerESP(p)
        return
    end
    
    -- Aplicar highlight (para jugadores en partida)
    if showPlayer then
        local hl = ensureHighlight(character, color)
        if hl then
            hl.Enabled = true
            hl.FillTransparency = 0.6
            hl.OutlineTransparency = 0.4
        end
    else
        clearHighlight(character)
    end
    
    -- Aplicar nametag (para todos, incluyendo lobby/spectator si está activado)
    local head = character:FindFirstChild("Head")
    if showName and validPart(head) then
        local text = p.Name
        
        -- Añadir etiqueta según estado
        if isLobby then
            text = text .. " [LOBBY]"
        elseif isSpec then
            text = text .. " [ESPECTADOR]"
        end
        
        local existingTag = head:FindFirstChild("ESP_Tag")
        
        if not existingTag then
            -- Crear nuevo tag optimizado
            local bb = Instance.new("BillboardGui")
            bb.Name = "ESP_Tag"
            bb.AlwaysOnTop = true
            bb.Size = UDim2.new(0, 180, 0, 30)
            bb.StudsOffset = Vector3.new(0, 3.5, 0)
            bb.Enabled = true
            bb.Parent = head
            
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.BackgroundTransparency = 1
            label.Size = UDim2.new(1, 0, 1, 0)
            label.Font = Enum.Font.GothamMedium
            label.Text = text
            label.TextSize = 13
            label.TextColor3 = color
            label.TextStrokeTransparency = 0.3
            label.TextStrokeColor3 = Color3.new(0, 0, 0)
            label.Parent = bb
            
            table.insert(espObjects, bb)
        else
            -- Actualizar tag existente
            local label = existingTag:FindFirstChild("Label")
            if label then
                label.Text = text
                label.TextColor3 = color
            end
            existingTag.Enabled = true
        end
    elseif head and head:FindFirstChild("ESP_Tag") then
        if not showName then
            head.ESP_Tag.Enabled = false
        end
    end
    
    -- Actualizar cache
    playerCache[p] = {
        lastUpdate = tick(),
        character = character,
        color = color,
        isLobby = isLobby,
        isSpectator = isSpec
    }
end

local function updateAllPlayersESP()
    if not (playerESPEnabled or nametagsEnabled) then return end
    
    local now = tick()
    if now - lastPlayerESPUpdate < PLAYER_ESP_INTERVAL then return end
    lastPlayerESPUpdate = now
    
    -- Procesar jugadores existentes primero (más rápido)
    for player, cacheData in pairs(playerCache) do
        if player and player.Parent then
            local shouldUpdate = true
            
            if cacheData then
                -- Solo actualizar si pasó más tiempo del intervalo o si cambió el estado
                local timeSinceUpdate = now - (cacheData.lastUpdate or 0)
                local currentIsLobby = isInLobby(player)
                local currentIsSpec = isSpectator(player)
                
                shouldUpdate = (timeSinceUpdate > PLAYER_ESP_INTERVAL) or 
                              (currentIsLobby ~= cacheData.isLobby) or
                              (currentIsSpec ~= cacheData.isSpectator)
            end
            
            if shouldUpdate then
                applyOptimizedPlayerESP(player)
            end
        else
            -- Limpiar jugador que ya no existe
            cleanPlayerESP(player)
            playerCache[player] = nil
        end
    end
    
    -- Verificar jugadores nuevos
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP and not playerCache[player] then
            if player.Character then
                applyOptimizedPlayerESP(player)
            end
        end
    end
end

local function startOptimizedESPLoop()
    if espLoopConn then 
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    -- Aplicar ESP inmediatamente a todos los jugadores
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            applyOptimizedPlayerESP(player)
        end
    end
    
    -- Iniciar loop de actualización
    espLoopConn = RunService.Heartbeat:Connect(function()
        updateAllPlayersESP()
    end)
end

local function stopOptimizedESPLoop()
    if espLoopConn then
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    -- Limpiar todos los jugadores
    for player, _ in pairs(playerCache) do
        cleanPlayerESP(player)
    end
    
    playerCache = {}
    lastPlayerESPUpdate = 0
end

-- Sistema de observadores (para detectar cambios inmediatos)
local function setupPlayerWatchers()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP then
            if not connections[p] then
                local playerConns = {}
                
                playerConns.characterAdded = p.CharacterAdded:Connect(function(character)
                    task.wait(1.5)  -- 1.5 segundos
                    if playerESPEnabled or nametagsEnabled then
                        applyOptimizedPlayerESP(p)
                    end
                end)
                
                playerConns.teamChanged = p:GetPropertyChangedSignal("Team"):Connect(function()
                    task.wait(1.5)  -- 1.5 segundos
                    if playerESPEnabled or nametagsEnabled then
                        applyOptimizedPlayerESP(p)
                    end
                end)
                
                playerConns.spectatorChanged = p:GetAttributeChangedSignal("Spectator"):Connect(function()
                    task.wait(1.5)  -- 1.5 segundos
                    if playerESPEnabled or nametagsEnabled then
                        applyOptimizedPlayerESP(p)
                    end
                end)
                
                connections[p] = playerConns
                
                -- Aplicar inicialmente
                if p.Character then
                    task.spawn(function()
                        task.wait(1.5)  -- 1.5 segundos
                        if playerESPEnabled or nametagsEnabled then
                            applyOptimizedPlayerESP(p)
                        end
                    end)
                end
            end
        end
    end
end

-- Inicializar al cargar
setupPlayerWatchers()

-- Observadores para nuevos jugadores
Players.PlayerAdded:Connect(function(p)
    if p ~= LP then
        task.wait(1.5)  -- 1.5 segundos
        setupPlayerWatchers()
        if playerESPEnabled or nametagsEnabled then
            applyOptimizedPlayerESP(p)
        end
    end
end)

Players.PlayerRemoving:Connect(function(p)
    if connections[p] then
        for _, conn in pairs(connections[p]) do
            pcall(function() conn:Disconnect() end)
        end
        connections[p] = nil
    end
    cleanPlayerESP(p)
    playerCache[p] = nil
end)

-- ============================================
-- SISTEMA ESP PARA GENERATORS
-- ============================================
local generatorESPEnabled = false
local generatorLoopConn = nil
local generatorCache = {}
local lastGeneratorUpdate = 0
local GENERATOR_ESP_INTERVAL = 1.5

local function ensureGeneratorHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    local hl = model:FindFirstChild("Generator_Highlight")
    if not hl then
        local success, result = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "Generator_Highlight"
            h.Adornee = model
            h.FillTransparency = 0.7
            h.OutlineTransparency = 0.2
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.FillColor = color
            h.OutlineColor = color
            h.Parent = model
            return h
        end)
        if success then 
            hl = result
            table.insert(espObjects, hl)
        else 
            return nil 
        end
    else
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
    end
    return hl
end

local function clearGeneratorHighlight(model)
    if model and model:FindFirstChild("Generator_Highlight") then
        local hl = model.Generator_Highlight
        hl:Destroy()
        for i, obj in ipairs(espObjects) do
            if obj == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

local function getGeneratorProgress(model)
    local progress = model:GetAttribute("RepairProgress") or 
                     model:GetAttribute("Progress") or 
                     model:GetAttribute("CurrentProgress") or 0
    
    if progress <= 1 then
        progress = progress * 100
    end
    
    return math.clamp(progress, 0, 100)
end

local function updateGeneratorESP()
    if not generatorESPEnabled then return end
    
    -- Control de tiempo: solo actualizar cada 1.5 segundos
    local now = tick()
    if now - lastGeneratorUpdate < GENERATOR_ESP_INTERVAL then return end
    lastGeneratorUpdate = now
    
    -- Buscar generadores de forma optimizada
    local foundGenerators = {}
    local generatorCount = 0
    
    -- Buscar solo en lugares específicos para optimizar
    local searchFolders = {
        Workspace:FindFirstChild("Map"),
        Workspace:FindFirstChild("Map1"),
        Workspace:FindFirstChild("Generators")
    }
    
    for _, folder in ipairs(searchFolders) do
        if folder then
            for _, obj in ipairs(folder:GetDescendants()) do
                if generatorCount >= 15 then break end  -- Límite para evitar lag
                
                if obj:IsA("Model") and (obj.Name:lower():find("generator") or 
                   obj:GetAttribute("IsGenerator") == true) then
                    
                    local basePart = firstBasePart(obj)
                    if basePart then
                        foundGenerators[obj] = basePart
                        generatorCount = generatorCount + 1
                    end
                end
            end
        end
    end
    
    -- También buscar en Workspace directamente (como fallback)
    if generatorCount == 0 then
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if generatorCount >= 10 then break end
            
            if obj:IsA("Model") and obj.Name:lower():find("generator") then
                local basePart = firstBasePart(obj)
                if basePart then
                    foundGenerators[obj] = basePart
                    generatorCount = generatorCount + 1
                end
            end
        end
    end
    
    -- Limpiar generadores que ya no existen
    for model, data in pairs(generatorCache) do
        if not alive(model) or not foundGenerators[model] then
            clearGeneratorHighlight(model)
            if data.part and data.part:FindFirstChild("Generator_Tag") then
                data.part.Generator_Tag:Destroy()
            end
            generatorCache[model] = nil
        end
    end
    
    -- Procesar generadores encontrados
    for model, basePart in pairs(foundGenerators) do
        local cacheData = generatorCache[model]
        local shouldUpdate = true
        
        if cacheData then
            -- Solo actualizar si pasaron más de 2 segundos (un poco más que el intervalo)
            shouldUpdate = (now - (cacheData.lastUpdate or 0)) > 2
        end
        
        if shouldUpdate then
            local progress = getGeneratorProgress(model)
            local color = generatorColor
            
            -- Color basado en progreso
            if progress >= 100 then
                color = Color3.fromRGB(0, 255, 0)
            elseif progress >= 70 then
                color = Color3.fromRGB(100, 255, 100)
            elseif progress >= 40 then
                color = Color3.fromRGB(255, 255, 0)
            else
                color = Color3.fromRGB(255, 50, 50)
            end
            
            -- Crear o actualizar highlight
            local hl = ensureGeneratorHighlight(model, color)
            if hl then
                hl.Enabled = true
                hl.FillTransparency = 0.85
                hl.OutlineTransparency = 0.6
            end
            
            -- Crear o actualizar tag
            local existingTag = basePart:FindFirstChild("Generator_Tag")
            if not existingTag then
                local bb = Instance.new("BillboardGui")
                bb.Name = "Generator_Tag"
                bb.AlwaysOnTop = true
                bb.Size = UDim2.new(0, 120, 0, 25)
                bb.StudsOffset = Vector3.new(0, 4, 0)
                bb.Enabled = true
                bb.Parent = basePart
                
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.BackgroundTransparency = 1
                label.Size = UDim2.new(1, 0, 1, 0)
                label.Font = Enum.Font.GothamMedium
                label.Text = string.format("%.0f%%", progress)
                label.TextSize = 11
                label.TextColor3 = color
                label.TextStrokeTransparency = 0.6
                label.TextStrokeColor3 = Color3.new(0, 0, 0)
                label.Parent = bb
                
                table.insert(espObjects, bb)
            else
                -- Solo actualizar texto si existe
                local label = existingTag:FindFirstChild("Label")
                if label then
                    label.Text = string.format("%.0f%%", progress)
                    label.TextColor3 = color
                end
            end
            
            -- Actualizar cache
            generatorCache[model] = {
                model = model,
                part = basePart,
                lastUpdate = now
            }
        end
    end
end

local function startGeneratorESPLoop()
    if generatorLoopConn then return end
    
    -- Aplicar ESP inmediatamente a los generadores existentes
    task.wait(1.5)
    updateGeneratorESP()
    
    -- Iniciar loop de actualización
    generatorLoopConn = RunService.Heartbeat:Connect(function()
        updateGeneratorESP()
    end)
end

local function stopGeneratorESPLoop()
    -- Detener el loop
    if generatorLoopConn then
        generatorLoopConn:Disconnect()
        generatorLoopConn = nil
    end
    
    -- Limpiar todos los generadores en cache
    for model, data in pairs(generatorCache) do
        if data and data.model then
            -- Limpiar highlight
            clearGeneratorHighlight(data.model)
            
            -- Limpiar tag
            if data.part and data.part:FindFirstChild("Generator_Tag") then
                data.part.Generator_Tag:Destroy()
            end
        end
    end
    
    -- Resetear variables
    generatorCache = {}
    lastGeneratorUpdate = 0
    
    -- También limpiar de la tabla espObjects
    for i = #espObjects, 1, -1 do
        local obj = espObjects[i]
        if obj and obj.Name == "Generator_Tag" then
            pcall(function() obj:Destroy() end)
            table.remove(espObjects, i)
        end
    end
end

-- ============================================
-- SISTEMA SPEED BOOST (SURVIVOR & KILLER)
-- ============================================
local speedBoostEnabled = false
local speedBoostValue = 1.25
local killerSpeedEnabled = false
local killerSpeedValue = 1.3
local speedBoostConnection = nil

local function applyUniversalSpeedBoost()
    local char = LP.Character
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Base speed según el rol (incluso en lobby)
    local baseSpeed = 16
    
    -- Aplicar boost según rol y toggle
    if killerSpeedEnabled and (getRole(LP) == "Killer" or isInLobby(LP)) then
        humanoid.WalkSpeed = baseSpeed * killerSpeedValue
        humanoid:SetAttribute("speedboost", killerSpeedValue)
    elseif speedBoostEnabled and (getRole(LP) == "Survivor" or isInLobby(LP)) then
        humanoid.WalkSpeed = baseSpeed * speedBoostValue
        humanoid:SetAttribute("speedboost", speedBoostValue)
    else
        -- Si no hay boost activo, restaurar velocidad normal
        humanoid.WalkSpeed = baseSpeed
        humanoid:SetAttribute("speedboost", nil)
    end
    
    -- También forzar que no haya speed reduction
    humanoid:SetAttribute("WalkSpeedMultiplier", 1.0)
end

local function startUniversalSpeedWatcher()
    if speedBoostConnection then return end
    
    speedBoostConnection = RunService.Heartbeat:Connect(function()
        applyUniversalSpeedBoost()
    end)
    
    -- Aplicar inmediatamente
    applyUniversalSpeedBoost()
end

local function stopUniversalSpeedWatcher()
    if speedBoostConnection then
        speedBoostConnection:Disconnect()
        speedBoostConnection = nil
    end
    
    -- Restaurar velocidad normal
    local char = LP.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 16
            humanoid:SetAttribute("speedboost", nil)
        end
    end
end

-- ============================================
-- SISTEMA GENERATOR BOOST
-- ============================================
local genBoostEnabled = false
local genBoostMultiplier = 2.0
local genBoostConnection = nil
local originalValues = {}

local function applyRealGeneratorBoost()
    if not genBoostEnabled then return end
    
    for _, generator in ipairs(Workspace:GetDescendants()) do
        if generator:IsA("Model") and (generator.Name:lower():find("generator") or generator.Name:lower():find("gen_")) then
            
            pcall(function()
                local currentProgress = generator:GetAttribute("Progress") or 
                                      generator:GetAttribute("progress") or 
                                      generator:GetAttribute("CurrentProgress") or 0
                
                if type(currentProgress) == "number" and currentProgress < 100 then
                    local newProgress = currentProgress + (0.5 * genBoostMultiplier)
                    generator:SetAttribute("Progress", newProgress)
                    generator:SetAttribute("progress", newProgress)
                    generator:SetAttribute("CurrentProgress", newProgress)
                end
                
                generator:SetAttribute("RepairSpeed", genBoostMultiplier)
                generator:SetAttribute("repairSpeed", genBoostMultiplier)
                generator:SetAttribute("SpeedMultiplier", genBoostMultiplier)
            end)
            
            for _, script in ipairs(generator:GetDescendants()) do
                if script:IsA("Script") or script:IsA("ModuleScript") or script:IsA("LocalScript") then
                    pcall(function()
                        local env = getfenv(script)
                        
                        if env.repairSpeed and type(env.repairSpeed) == "number" then
                            if not originalValues[script] then
                                originalValues[script] = env.repairSpeed
                            end
                            env.repairSpeed = originalValues[script] * genBoostMultiplier
                        end
                        
                        if env.RepairSpeed and type(env.RepairSpeed) == "number" then
                            if not originalValues[script] then
                                originalValues[script] = env.RepairSpeed
                            end
                            env.RepairSpeed = originalValues[script] * genBoostMultiplier
                        end
                        
                        if env.progress and type(env.progress) == "number" then
                            env.progress = math.min(100, env.progress + (0.3 * genBoostMultiplier))
                        end
                        
                        if env.Progress and type(env.Progress) == "number" then
                            env.Progress = math.min(100, env.Progress + (0.3 * genBoostMultiplier))
                        end
                        
                        if env.repairTime and type(env.repairTime) == "number" then
                            if not originalValues[script] then
                                originalValues[script] = env.repairTime
                            end
                            env.repairTime = originalValues[script] / genBoostMultiplier
                        end
                    end)
                end
            end
        end
    end
end

local function interceptPlayerRepair()
    if not LP.Character then return end
    
    for _, tool in ipairs(LP.Character:GetChildren()) do
        if tool:IsA("Tool") then
            local toolName = tool.Name:lower()
            if toolName:find("repair") or toolName:find("tool") or toolName:find("kit") then
                
                for _, script in ipairs(tool:GetDescendants()) do
                    if script:IsA("Script") then
                        pcall(function()
                            local env = getfenv(script)
                            
                            if env.repair then
                                local originalRepair = env.repair
                                env.repair = function(...)
                                    if genBoostEnabled then
                                        task.spawn(function()
                                            for i = 1, 20 do
                                                applyRealGeneratorBoost()
                                                task.wait(0.1)
                                            end
                                        end)
                                    end
                                    return originalRepair(...)
                                end
                            end
                        end)
                    end
                end
            end
        end
    end
end

local function startGenBoostWatcher()
    if genBoostConnection then return end
    
    genBoostConnection = RunService.Heartbeat:Connect(function()
        if genBoostEnabled then
            applyRealGeneratorBoost()
            interceptPlayerRepair()
            
            pcall(function()
                if LP.Character then
                    LP.Character:SetAttribute("RepairBoost", genBoostMultiplier)
                    LP.Character:SetAttribute("GeneratorSpeed", genBoostMultiplier)
                    
                    local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:SetAttribute("ActionSpeed", genBoostMultiplier)
                    end
                end
            end)
        end
    end)
end

local function removeGenBoost()
    for script, originalValue in pairs(originalValues) do
        if script.Parent then
            pcall(function()
                local env = getfenv(script)
                if env.repairSpeed then
                    env.repairSpeed = originalValue
                end
                if env.RepairSpeed then
                    env.RepairSpeed = originalValue
                end
                if env.repairTime then
                    env.repairTime = originalValue
                end
            end)
        end
    end
    
    pcall(function()
        if LP.Character then
            LP.Character:SetAttribute("RepairBoost", nil)
            LP.Character:SetAttribute("GeneratorSpeed", nil)
            
            local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:SetAttribute("ActionSpeed", nil)
            end
        end
    end)
    
    originalValues = {}
end

-- ============================================
-- SISTEMA PERFECT SKILLCHECK
-- ============================================
local perfectSkillEnabled = false
local perfectSkillConnection = nil

local function findSkillCheckUI()
    local playerGui = LP:FindFirstChild("PlayerGui")
    if not playerGui then return nil end
    
    for _, screenGui in ipairs(playerGui:GetChildren()) do
        if screenGui:IsA("ScreenGui") then
            for _, obj in ipairs(screenGui:GetDescendants()) do
                if obj.Name:lower():find("skillcheck") or 
                   obj.Name:lower():find("skill") and obj:IsA("Frame") then
                    return obj
                end
            end
        end
    end
    return nil
end

local function getSkillCheckComponents(skillCheckUI)
    local bar, zone, pointer
    
    for _, child in ipairs(skillCheckUI:GetDescendants()) do
        if child:IsA("Frame") then
            local size = child.AbsoluteSize
            if size.X > 200 and size.Y < 50 then
                bar = child
            elseif child.Name:lower():find("zone") or child.Name:lower():find("perfect") then
                zone = child
            elseif child.Name:lower():find("pointer") or child.Name:lower():find("marker") then
                pointer = child
            end
        end
    end
    
    return bar, zone, pointer
end

local function executePerfectSkillCheck()
    if not perfectSkillEnabled then return end
    
    local skillCheckUI = findSkillCheckUI()
    if not skillCheckUI then return end
    
    local bar, zone, pointer = getSkillCheckComponents(skillCheckUI)
    if not (bar and zone and pointer) then return end
    
    local zoneCenter = zone.AbsolutePosition.X + (zone.AbsoluteSize.X / 2)
    local barStart = bar.AbsolutePosition.X
    local barWidth = bar.AbsoluteSize.X
    
    if barWidth > 0 then
        local perfectPosition = (zoneCenter - barStart) / barWidth
        perfectPosition = math.clamp(perfectPosition, 0, 1)
        
        pcall(function()
            if pointer:IsA("Frame") then
                pointer.Position = UDim2.new(perfectPosition, 0, pointer.Position.Y.Scale, pointer.Position.Y.Offset)
            end
        end)
        
        local args = {
            [1] = perfectPosition,
            [2] = true
        }
        
        pcall(function()
            for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do
                if remote:IsA("RemoteEvent") and (remote.Name:lower():find("skill") or remote.Name:lower():find("check")) then
                    remote:FireServer(args)
                    break
                end
            end
            
            LP.Character:SetAttribute("LastSkillCheck", perfectPosition)
            LP.Character:SetAttribute("SkillCheckPerfect", true)
        end)
    end
end

local function startPerfectSkillCheck()
    if perfectSkillConnection then return end
    
    perfectSkillConnection = RunService.Heartbeat:Connect(function()
        executePerfectSkillCheck()
    end)
end

local function stopPerfectSkillCheck()
    if perfectSkillConnection then
        perfectSkillConnection:Disconnect()
        perfectSkillConnection = nil
    end
end

-- ============================================
-- SISTEMA NO SKILLCHECK
-- ============================================
local noSkillCheckEnabled = false
local noSkillCheckConnection = nil

local function removeSkillChecks()
    if not noSkillCheckEnabled then return end
    
    local playerGui = LP:FindFirstChild("PlayerGui")
    if not playerGui then return end
    
    for _, screenGui in ipairs(playerGui:GetChildren()) do
        if screenGui:IsA("ScreenGui") then
            for _, obj in ipairs(screenGui:GetDescendants()) do
                if obj.Name:lower():find("skillcheck") or 
                   obj.Name:lower():find("skill") and (obj:IsA("Frame") or obj:IsA("ImageLabel")) then
                    pcall(function() obj:Destroy() end)
                end
            end
        end
    end
    
    pcall(function()
        LP.Character:SetAttribute("SkipSkillCheck", true)
        LP.Character:SetAttribute("AutoCompleteSkillCheck", true)
    end)
end

local function startNoSkillCheck()
    if noSkillCheckConnection then return end
    
    noSkillCheckConnection = RunService.Heartbeat:Connect(function()
        removeSkillChecks()
    end)
    
    removeSkillChecks()
end

local function stopNoSkillCheck()
    if noSkillCheckConnection then
        noSkillCheckConnection:Disconnect()
        noSkillCheckConnection = nil
    end
    
    pcall(function()
        if LP.Character then
            LP.Character:SetAttribute("SkipSkillCheck", nil)
            LP.Character:SetAttribute("AutoCompleteSkillCheck", nil)
        end
    end)
end

-- ============================================
-- SISTEMA LOW GRAPHICS
-- ============================================

local lowGraphicsEnabled = false
local originalShadows = true

local function applySimpleLowGraphics()
    if not lowGraphicsEnabled then return end
    
    -- SOLO DESACTIVAR SOMBRAS
    pcall(function()
        Lighting.GlobalShadows = false
        
        -- Desactivar sombras en partes
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CastShadow = false
            end
        end
    end)
end

local function restoreSimpleGraphics()
    pcall(function()
        Lighting.GlobalShadows = originalShadows
        
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CastShadow = true
            end
        end
    end)
end

-- ============================================
-- VENTANA RAYFIELD (ORGANIZACIÓN PEDIDA)
-- ============================================
local Window = Rayfield:CreateWindow({
    Name = "LoreOnTop",
    LoadingTitle = "Violence District",
    LoadingSubtitle = "Hecho por kcha abuelas3000",
    ConfigurationSaving = {Enabled = true, FolderName = "ESP_Suite", FileName = "esp_config"},
    KeySystem = false
})

-- ============================================
-- PESTAÑA VISUAL (ESP)
-- ============================================
local VisualTab = Window:CreateTab("Visual")

-- Sección Player ESP
VisualTab:CreateSection("Player ESP")

VisualTab:CreateToggle({
    Name = "Players ESP",
    CurrentValue = false,
    Flag = "PlayerESP",
    Callback = function(s)
        playerESPEnabled = s
        if s or nametagsEnabled then
            startOptimizedESPLoop()
        else
            stopOptimizedESPLoop()
        end
    end
})

VisualTab:CreateToggle({
    Name = "Mostrar Nombres",
    CurrentValue = false,
    Flag = "Nametags",
    Callback = function(s)
        nametagsEnabled = s
        if s or playerESPEnabled then
            startOptimizedESPLoop()
        else
            stopOptimizedESPLoop()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Survivor",
    Color = survivorColor,
    Flag = "SurvivorCol",
    Callback = function(c) 
        survivorColor = c 
        -- Forzar actualización de todos los jugadores
        for player, data in pairs(playerCache) do
            if getRole(player) == "Survivor" then
                applyOptimizedPlayerESP(player)
            end
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Killer",
    Color = killerColor,
    Flag = "KillerCol",
    Callback = function(c) 
        killerColor = c 
        -- Forzar actualización de todos los jugadores
        for player, data in pairs(playerCache) do
            if getRole(player) == "Killer" then
                applyOptimizedPlayerESP(player)
            end
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Lobby",
    Color = lobbyColor,
    Flag = "LobbyCol",
    Callback = function(c) 
        lobbyColor = c 
        -- Forzar actualización de todos los jugadores
        for player, data in pairs(playerCache) do
            if isInLobby(player) then
                applyOptimizedPlayerESP(player)
            end
        end
    end
})

-- Sección Generator ESP
VisualTab:CreateSection("Generator ESP")

VisualTab:CreateToggle({
    Name = "Generator ESP",
    CurrentValue = false,
    Flag = "GeneratorESP",
    Callback = function(s)
        generatorESPEnabled = s
        if s then 
            startGeneratorESPLoop() 
        else 
            stopGeneratorESPLoop() 
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Generator Color",
    Color = generatorColor,
    Flag = "GenCol",
    Callback = function(c) 
        generatorColor = c 
    end
})

-- ============================================
-- PESTAÑA SURVIVORS
-- ============================================
local SurvivorTab = Window:CreateTab("Survivors")

-- Sección Speed Boost
SurvivorTab:CreateSection("Speed Boost")

SurvivorTab:CreateToggle({
    Name = "Enable Speed Boost",
    CurrentValue = false,
    Flag = "SpeedBoostToggle",
    Callback = function(state)
        speedBoostEnabled = state
        if state then
            startUniversalSpeedWatcher()
        else
            stopUniversalSpeedWatcher()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Speed Multiplier",
    Range = {1.00, 3.00},
    Increment = 0.10,
    Suffix = "x",
    CurrentValue = speedBoostValue,
    Flag = "SpeedBoostValue",
    Callback = function(v)
        speedBoostValue = v
        applyUniversalSpeedBoost()
        end
})

-- Sección Generator Boost
SurvivorTab:CreateSection("Generator Boost")

SurvivorTab:CreateToggle({
    Name = "Generator Boost",
    CurrentValue = false,
    Callback = function(state)
        genBoostEnabled = state
        
        if state then
            startGenBoostWatcher()
        else
            if genBoostConnection then
                genBoostConnection:Disconnect()
                genBoostConnection = nil
            end
            removeGenBoost()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Velocidad de Reparación",
    Range = {1.5, 10.0},
    Increment = 0.5,
    Suffix = "x",
    CurrentValue = genBoostMultiplier,
    Callback = function(value)
        genBoostMultiplier = value
    end
})

-- Sección SkillCheck
SurvivorTab:CreateSection("SkillCheck")

SurvivorTab:CreateToggle({
    Name = "Enable Perfect Skillcheck",
    CurrentValue = false,
    Callback = function(v)
        perfectSkillEnabled = v
        if v then startPerfectSkillCheck() else stopPerfectSkillCheck() end
    end
})

SurvivorTab:CreateToggle({
    Name = "Enable No Skillchecks",
    CurrentValue = false,
    Callback = function(v)
        if v then startNoSkillCheck() else stopNoSkillCheck() end
    end
})

-- Sección Healing
SurvivorTab:CreateSection("Heal")

local instaHealEnabled = false
local healRemoteHook = nil
local originalHealFireServer = nil
local healConnections = {}

SurvivorTab:CreateToggle({
    Name = "Insta Heal Others",
    CurrentValue = false,
    Callback = function(v)
        instaHealEnabled = v
        
        if v then
            -- Buscar el RemoteEvent de curación
            local healRemote = findHealRemote()
            
            if healRemote then
                -- Interceptar el evento de curación
                local oldFireServer = healRemote.FireServer
                healRemote.FireServer = newcclosure(function(self, ...)
                    local args = {...}
                    
                    if instaHealEnabled and #args >= 2 then
                        local targetPlayer = args[1]
                        local healAction = args[2]
                        
                        -- Verificar que no sea auto-curación
                        if targetPlayer ~= LP and 
                           (healAction == "Heal" or healAction == "heal" or healAction == "StartHeal") then
                            
                            -- Forzar curación completa al objetivo
                            if targetPlayer.Character then
                                -- Resetear atributos de heridas
                                targetPlayer.Character:SetAttribute("Injured", false)
                                targetPlayer.Character:SetAttribute("Bleeding", false)
                                targetPlayer.Character:SetAttribute("Health", 100)
                                
                                -- También buscar y ajustar el Humanoid
                                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    humanoid.Health = humanoid.MaxHealth
                                end
                                
                                -- Enviar notificación visual
                                Rayfield:Notify({
                                    Title = "Insta Heal",
                                    Content = "Jugador curado completamente: " .. targetPlayer.Name,
                                    Duration = 2
                                })
                            end
                        end
                    end
                    
                    return oldFireServer(self, ...)
                end)
                
                -- Guardar referencia para restaurar después
                originalHealFireServer = oldFireServer
                healRemoteHook = healRemote
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "No se encontró el evento de curación",
                    Duration = 3,
                    Image = 4483362458
                })
            end
            
            -- También conectar a eventos de interacción
            setupHealInteractions()
            
        else
            -- Desactivar y restaurar
            if healRemoteHook and originalHealFireServer then
                healRemoteHook.FireServer = originalHealFireServer
                healRemoteHook = nil
                originalHealFireServer = nil
            end
            
            -- Limpiar conexiones
            if healConnections then
                for _, conn in pairs(healConnections) do
                    conn:Disconnect()
                end
                healConnections = {}
            end
        end
    end
})

-- Función para encontrar el RemoteEvent de curación
function findHealRemote()
    -- Buscar en diferentes lugares comunes
    local places = {
        ReplicatedStorage,
        Workspace,
        game:GetService("Players")
    }
    
    for _, place in ipairs(places) do
        for _, obj in ipairs(place:GetDescendants()) do
            if obj:IsA("RemoteEvent") then
                local name = obj.Name:lower()
                if name:find("heal") or 
                   name:find("health") or 
                   name:find("cure") or 
                   name:find("revive") then
                    return obj
                end
            end
        end
    end
    
    -- Buscar también en Scripts específicos
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            for _, tool in ipairs(player.Character:GetChildren()) do
                if tool:IsA("Tool") and (tool.Name:lower():find("med") or tool.Name:lower():find("heal")) then
                    for _, script in ipairs(tool:GetDescendants()) do
                        if script:IsA("RemoteEvent") then
                            return script
                        end
                    end
                end
            end
        end
    end
    
    return nil
end

-- Configurar interacciones de curación
function setupHealInteractions()
    healConnections = healConnections or {}
    
    -- Monitorear cuando te acercas a jugadores heridos
    local proximityCheck
    proximityCheck = game:GetService("RunService").Heartbeat:Connect(function()
        if not instaHealEnabled then 
            proximityCheck:Disconnect()
            return 
        end
        
        local myChar = LP.Character
        if not myChar then return end
        
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        
        -- Buscar jugadores cercanos heridos
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LP and player.Character then
                local targetChar = player.Character
                local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                
                if targetRoot then
                    local distance = (myRoot.Position - targetRoot.Position).Magnitude
                    
                    -- Si está dentro del rango de curación (unidades de Roblox)
                    if distance < 10 then
                        -- Verificar si está herido
                        local isInjured = targetChar:GetAttribute("Injured") or
                                         targetChar:GetAttribute("Bleeding") or
                                         (targetChar:FindFirstChildOfClass("Humanoid") and 
                                          targetChar:FindFirstChildOfClass("Humanoid").Health < 100)
                        
                        if isInjured then
                            -- Auto-activar curación
                            pcall(function()
                                -- Intentar diferentes métodos
                                local args = {player, "Heal", true, 100}
                                
                                -- Enviar evento de curación completa
                                if healRemoteHook then
                                    healRemoteHook:FireServer(unpack(args))
                                end
                                
                                -- También forzar atributos directamente
                                targetChar:SetAttribute("Injured", false)
                                targetChar:SetAttribute("Bleeding", false)
                                targetChar:SetAttribute("Health", 100)
                                
                                local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    humanoid.Health = humanoid.MaxHealth
                                end
                            end)
                        end
                    end
                end
            end
        end
    end)
    
    table.insert(healConnections, proximityCheck)
end

-- Sección Anti-Ralentización
SurvivorTab:CreateSection("Anti-Ralentización")

local antiRalentizacionEnabled = false
local antiRalentizacionConnection = nil
local originalWalkspeed = 16

SurvivorTab:CreateToggle({
    Name = "Anti-Ralentización",
    CurrentValue = false,
    Callback = function(v)
        antiRalentizacionEnabled = v
        
        if v then
            -- Conexión para prevenir cualquier ralentización
            antiRalentizacionConnection = RunService.Heartbeat:Connect(function()
                local char = LP.Character
                if not char then return end
                
                pcall(function()
                    -- 1. Prevenir ralentización por caída
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        -- Verificar estado de caída
                        local isFalling = humanoid:GetState() == Enum.HumanoidStateType.Freefall
                        local isLanded = humanoid:GetState() == Enum.HumanoidStateType.Landed
                        
                        if isFalling or isLanded then
                            -- Resetear el tiempo de recuperación de caída
                            humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                        end
                        
                        -- Forzar walkspeed normal
                        local targetSpeed = originalWalkspeed
                        if speedBoostEnabled and speedBoostValue then
                            targetSpeed = originalWalkspeed * speedBoostValue
                        end
                        
                        -- Prevenir que el juego reduzca la velocidad
                        humanoid.WalkSpeed = targetSpeed
                        
                        -- También forzar jumppower si es necesario
                        humanoid.JumpPower = 50
                    end
                    
                    -- 2. Eliminar atributos de ralentización
                    char:SetAttribute("SlowDuration", 0)
                    char:SetAttribute("StunDuration", 0)
                    char:SetAttribute("FallRecovery", 0)
                    char:SetAttribute("Immobile", false)
                    char:SetAttribute("MovementDisabled", false)
                    
                    -- 3. Eliminar efectos de slow/stun
                    for _, effect in ipairs(char:GetChildren()) do
                        local nameLower = effect.Name:lower()
                        if (effect:IsA("BoolValue") or effect:IsA("NumberValue") or effect:IsA("ObjectValue")) and
                           (nameLower:find("slow") or nameLower:find("stun") or nameLower:find("debuff") or 
                            nameLower:find("immobile") or nameLower:find("recovery")) then
                            effect:Destroy()
                        end
                    end
                    
                    -- 4. Prevenir animaciones de ralentización
                    local animator = char:FindFirstChildOfClass("Animator")
                    if animator then
                        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                            local animName = track.Animation.Name:lower()
                            if animName:find("stun") or animName:find("fall") or animName:find("recovery") or
                               animName:find("slow") or animName:find("hurt") then
                                track:Stop()
                            end
                        end
                    end
                    
                    -- 5. Mantener velocidad en partes del cuerpo
                    local rootPart = char:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        -- Prevenir que se reduzca la velocidad de movimiento
                        local currentVelocity = rootPart.Velocity
                        if currentVelocity.Magnitude < 1 then
                            rootPart.Velocity = Vector3.new(currentVelocity.X, currentVelocity.Y, currentVelocity.Z)
                        end
                        
                        -- Eliminar cualquier fuerza que cause ralentización
                        for _, force in ipairs(rootPart:GetChildren()) do
                            if force:IsA("BodyVelocity") or force:IsA("BodyForce") then
                                if force.Name:lower():find("slow") or force.Name:lower():find("stun") then
                                    force:Destroy()
                                end
                            end
                        end
                    end
                    
                    -- 6. Interceptar eventos de daño/ralentización
                    for _, descendant in ipairs(char:GetDescendants()) do
                        if descendant:IsA("RemoteEvent") then
                            local nameLower = descendant.Name:lower()
                            if nameLower:find("stun") or nameLower:find("slow") or nameLower:find("hit") then
                                local oldFireServer = descendant.FireServer
                                descendant.FireServer = newcclosure(function(self, ...)
                                    if antiRalentizacionEnabled then
                                        -- Ignorar eventos de ralentización
                                        return nil
                                    end
                                    return oldFireServer(self, ...)
                                end)
                            end
                        end
                    end
                end)
            end)
            
            -- También monitorear el evento StateChanged del Humanoid
            local function monitorHumanoidState()
                local char = LP.Character
                if char then
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.StateChanged:Connect(function(oldState, newState)
                            if antiRalentizacionEnabled then
                                -- Detectar y prevenir estados de ralentización
                                if newState == Enum.HumanoidStateType.Freefall or 
                                   newState == Enum.HumanoidStateType.GettingUp or
                                   newState == Enum.HumanoidStateType.Landed then
                                    
                                    task.wait(0.05) -- Pequeño delay
                                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                                    
                                    -- Restaurar velocidad inmediatamente
                                    local targetSpeed = originalWalkspeed
                                    if speedBoostEnabled and speedBoostValue then
                                        targetSpeed = originalWalkspeed * speedBoostValue
                                    end
                                    humanoid.WalkSpeed = targetSpeed
                                end
                            end
                        end)
                    end
                end
            end
            
            -- Iniciar monitoreo
            monitorHumanoidState()
            
            -- Reconectar cuando el personaje cambie
            LP.CharacterAdded:Connect(function()
                task.wait(1) -- Esperar a que el personaje cargue
                monitorHumanoidState()
            end)
            
            -- Aplicar inmediatamente
            task.spawn(function()
                repeat task.wait(0.1) until LP.Character
                local char = LP.Character
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    originalWalkspeed = humanoid.WalkSpeed
                    humanoid.WalkSpeed = originalWalkspeed * (speedBoostEnabled and speedBoostValue or 1)
                    humanoid.JumpPower = 50
                    humanoid.AutoRotate = true
                end
            end)
            
        else
            -- Desactivar
            if antiRalentizacionConnection then
                antiRalentizacionConnection:Disconnect()
                antiRalentizacionConnection = nil
            end
            
            -- Restaurar velocidad original
            task.spawn(function()
                local char = LP.Character
                if char then
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.WalkSpeed = originalWalkspeed
                    end
                end
            end)
        end
    end
})

-- ============================================
-- PESTAÑA KILLERS
-- ============================================
local KillerTab = Window:CreateTab("Killers")

-- Sección Speed Boost Killer
KillerTab:CreateSection("Speed Boost")

KillerTab:CreateToggle({
    Name = "Killer Speed Boost",
    CurrentValue = false,
    Callback = function(v)
        killerSpeedEnabled = v
        applyUniversalSpeedBoost()
    end
})

KillerTab:CreateSlider({
    Name = "Killer Speed Multiplier",
    Range = {1.0, 3.0},
    Increment = 0.1,
    CurrentValue = killerSpeedValue,
    Callback = function(v)
        killerSpeedValue = v
        if killerSpeedEnabled then
            applyUniversalSpeedBoost()
        end
    end
})

-- Sección Anti-Stun
KillerTab:CreateSection("Anti-Stun")

KillerTab:CreateToggle({
    Name = "Anti-Stun",
    CurrentValue = false,
    Callback = function(v)
        if v then
            -- Activar anti-stun
            local char = LP.Character
            if char then
                char:SetAttribute("IsStunned", false)
                
                -- Monitorear constantemente para evitar stun
                RunService.Heartbeat:Connect(function()
                    if char then
                        char:SetAttribute("IsStunned", false)
                    end
                end)
            end
        else
            -- Desactivar
            local char = LP.Character
            if char then
                char:SetAttribute("IsStunned", nil)
            end
        end
    end
})

-- Sección Hitbox Expander (Invisible)
KillerTab:CreateSection("Hitbox Expander")

local hitboxExpanderEnabled = false
local hitboxMultiplier = 1.5
local hitboxTransparency = 0.9
local hitboxWelds = {}
local originalHits = {}

-- Función para interceptar los ataques del killer
local function interceptKillerAttacks()
    local killerChar = LP.Character
    if not killerChar then return end
    
    -- Buscar herramientas de ataque del killer
    for _, tool in ipairs(killerChar:GetChildren()) do
        if tool:IsA("Tool") and (tool.Name:lower():find("knife") or tool.Name:lower():find("weapon") or tool.Name:lower():find("attack")) then
            -- Buscar scripts de ataque
            for _, script in ipairs(tool:GetDescendants()) do
                if script:IsA("LocalScript") or script:IsA("Script") then
                    if script.Source and (script.Source:find("Hit") or script.Source:find("hit") or script.Source:find("Damage")) then
                        -- Interceptar funciones de daño
                        local env = getfenv(script)
                        local originalHitFunction = env.Hit or env.hit or env.onHit
                        
                        if originalHitFunction and type(originalHitFunction) == "function" then
                            originalHits[script] = originalHitFunction
                            
                            local function expandedHit(target, ...)
                                if hitboxExpanderEnabled and target and target:IsA("Model") then
                                    -- Verificar si el objetivo es un survivor
                                    local player = Players:GetPlayerFromCharacter(target)
                                    if player and getRole(player) == "Survivor" then
                                        -- Verificar distancia con hitbox expandida
                                        local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                                        local targetRoot = target:FindFirstChild("HumanoidRootPart")
                                        
                                        if killerRoot and targetRoot then
                                            local distance = (killerRoot.Position - targetRoot.Position).Magnitude
                                            local baseRange = 10 -- Rango base del ataque
                                            local expandedRange = baseRange * hitboxMultiplier
                                            
                                            -- Si está dentro del rango expandido, permitir el golpe
                                            if distance <= expandedRange then
                                                return originalHitFunction(target, ...)
                                            else
                                                return nil
                                            end
                                        end
                                    end
                                end
                                return originalHitFunction(target, ...)
                            end
                            
                            if env.Hit then env.Hit = expandedHit end
                            if env.hit then env.hit = expandedHit end
                            if env.onHit then env.onHit = expandedHit end
                        end
                    end
                end
            end
        end
    end
end

-- Función para crear hitbox visual (solo visual, no funcional)
local function createInvisibleHitbox(character, multiplier)
    if not character or not character.Parent then return nil end
    
    -- Buscar si ya existe una hitbox
    local existingHitbox = character:FindFirstChild("InvisibleHitbox")
    if existingHitbox then
        existingHitbox:Destroy()
    end
    
    -- Crear una parte invisible para la hitbox
    local hitboxPart = Instance.new("Part")
    hitboxPart.Name = "InvisibleHitbox"
    hitboxPart.Anchored = false
    hitboxPart.CanCollide = false
    hitboxPart.Transparency = hitboxTransparency
    hitboxPart.Color = Color3.fromRGB(255, 0, 0)
    hitboxPart.Material = Enum.Material.Neon
    hitboxPart.CastShadow = false
    hitboxPart.Locked = true
    
    -- Usar Attachment en lugar de Weld para mejor seguimiento
    local rootPart = character:FindFirstChild("HumanoidRootPart") or 
                     character:FindFirstChild("Torso") or 
                     character:FindFirstChild("UpperTorso")
    
    if rootPart then
        -- Ajustar tamaño basado en el estado del survivor
        local isDowned = character:GetAttribute("Downed") or 
                        character:GetAttribute("Injured") or false
        
        local baseSize
        if isDowned then
            baseSize = Vector3.new(3, 1.5, 3) -- Hitbox más plana para survivors caídos
        else
            baseSize = rootPart.Size
        end
        
        hitboxPart.Size = baseSize * multiplier
        hitboxPart.CFrame = rootPart.CFrame
        
        -- Crear Attachment para mejor seguimiento
        local attachment = Instance.new("Attachment")
        attachment.Parent = rootPart
        
        local bodyPosition = Instance.new("BodyPosition")
        bodyPosition.P = 15000
        bodyPosition.D = 1000
        bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyPosition.Position = rootPart.Position
        bodyPosition.Parent = hitboxPart
        
        -- Conectar para actualizar posición
        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not hitboxPart or not hitboxPart.Parent then
                connection:Disconnect()
                return
            end
            
            if rootPart and rootPart.Parent then
                bodyPosition.Position = rootPart.Position
                
                -- Actualizar rotación también
                hitboxPart.CFrame = CFrame.new(rootPart.Position) * rootPart.CFrame.Rotation
                
                -- Ajustar transparencia basado en estado
                if character:GetAttribute("OnHook") or character:GetAttribute("BeingCarried") then
                    hitboxPart.Transparency = 1
                else
                    hitboxPart.Transparency = hitboxTransparency
                end
            end
        end)
        
        hitboxWelds[character] = connection
    end
    
    hitboxPart.Parent = character
    return hitboxPart
end

-- Interceptar eventos de agarre y gancho
local function setupHookInterception()
    -- Buscar RemoteEvents relacionados con ganchos
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("RemoteEvent") and (obj.Name:lower():find("hook") or obj.Name:lower():find("carry")) then
            local oldFireServer = obj.FireServer
            obj.FireServer = newcclosure(function(self, ...)
                local args = {...}
                
                if hitboxExpanderEnabled and #args > 0 then
                    local target = args[1]
                    if typeof(target) == "Instance" and target:IsA("Model") then
                        local player = Players:GetPlayerFromCharacter(target)
                        if player and getRole(player) == "Survivor" then
                            -- Limpiar hitbox temporalmente durante el agarre
                            local hitbox = target:FindFirstChild("InvisibleHitbox")
                            if hitbox then
                                hitbox.Transparency = 1
                            end
                        end
                    end
                end
                
                return oldFireServer(self, ...)
            end)
        end
    end
end

KillerTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = false,
    Callback = function(v)
        hitboxExpanderEnabled = v
        if v then
            -- Interceptar ataques del killer
            interceptKillerAttacks()
            
            -- Configurar intercepción de ganchos
            setupHookInterception()
            
            -- Crear hitbox visual para todos los survivors
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LP and getRole(player) == "Survivor" then
                    if player.Character then
                        createInvisibleHitbox(player.Character, hitboxMultiplier)
                    end
                    
                    -- Conectar para cuando el personaje cambie
                    player.CharacterAdded:Connect(function(character)
                        task.wait(0.5)  -- Esperar a que cargue completamente
                        if hitboxExpanderEnabled then
                            createInvisibleHitbox(character, hitboxMultiplier)
                        end
                    end)
                end
            end
            
        else
            -- Eliminar todas las hitbox visuales
            for _, player in ipairs(Players:GetPlayers()) do
                if player.Character then
                    local hitbox = player.Character:FindFirstChild("InvisibleHitbox")
                    if hitbox then
                        hitbox:Destroy()
                    end
                end
            end
            
            -- Limpiar conexiones
            for character, connection in pairs(hitboxWelds) do
                if connection then
                    connection:Disconnect()
                end
            end
            hitboxWelds = {}
            
            -- Restaurar funciones originales
            for script, originalFunc in pairs(originalHits) do
                local env = getfenv(script)
                if env.Hit == expandedHit then env.Hit = originalFunc end
                if env.hit == expandedHit then env.hit = originalFunc end
                if env.onHit == expandedHit then env.onHit = originalFunc end
            end
            originalHits = {}
        end
    end
})

KillerTab:CreateSlider({
    Name = "Hitbox Size Multiplier",
    Range = {1.0, 5.0},
    Increment = 0.1,
    CurrentValue = hitboxMultiplier,
    Suffix = "x",
    Callback = function(v)
        hitboxMultiplier = v
        if hitboxExpanderEnabled then
            -- Actualizar tamaño de todas las hitbox existentes
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LP and getRole(player) == "Survivor" and player.Character then
                    local hitbox = player.Character:FindFirstChild("InvisibleHitbox")
                    if hitbox then
                        local rootPart = player.Character:FindFirstChild("HumanoidRootPart") or 
                                       player.Character:FindFirstChild("Torso")
                        if rootPart then
                            local isDowned = player.Character:GetAttribute("Downed")
                            local baseSize = isDowned and Vector3.new(3, 1.5, 3) or rootPart.Size
                            hitbox.Size = baseSize * hitboxMultiplier
                        end
                    end
                end
            end
        end
    end
})

KillerTab:CreateSlider({
    Name = "Hitbox Transparency",
    Range = {0.1, 1.0},
    Increment = 0.1,
    CurrentValue = hitboxTransparency,
    Callback = function(v)
        hitboxTransparency = v
        if hitboxExpanderEnabled then
            -- Actualizar transparencia de todas las hitbox
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LP and getRole(player) == "Survivor" and player.Character then
                    local hitbox = player.Character:FindFirstChild("InvisibleHitbox")
                    if hitbox then
                        -- No hacer completamente invisible si no está en gancho
                        if not player.Character:GetAttribute("OnHook") then
                            hitbox.Transparency = math.min(hitboxTransparency, 0.95)
                        end
                    end
                end
            end
        end
    end
})

-- Sección Full Break Motor
KillerTab:CreateSection("Full Break Motor")

local fullBreakEnabled = false
local breakConnection = nil
local generatorStates = {}

local function setupGeneratorMonitor(generator)
    if generatorStates[generator] then return end
    
    generatorStates[generator] = {
        lastProgress = generator:GetAttribute("RepairProgress") or 1,
        lastCheck = tick()
    }
    
    -- Monitorear cambios en el atributo RepairProgress
    generator:GetAttributeChangedSignal("RepairProgress"):Connect(function()
        if not fullBreakEnabled or getRole(LP) ~= "Killer" then return end
        
        local currentProgress = generator:GetAttribute("RepairProgress") or 1
        local lastProgress = generatorStates[generator].lastProgress
        
        if currentProgress < lastProgress then
          
            if tick() - generatorStates[generator].lastCheck < 2 then
              
                if LP.Character then
                    local hrp = LP.Character:FindFirstChild("HumanoidRootPart")
                    local genPart = generator.PrimaryPart or generator:FindFirstChildWhichIsA("BasePart")
                    
                    if hrp and genPart and (hrp.Position - genPart.Position).Magnitude < 15 then
                      
                        task.wait(0.1)
                        
                        pcall(function()
                            generator:SetAttribute("RepairProgress", 0)
                            generator:SetAttribute("ProgressBar", 0)
                            
                            -- Efecto visual/sonoro opcional
                            if genPart then
                                local sound = Instance.new("Sound")
                                sound.SoundId = "rbxassetid://9114822715"
                                sound.Volume = 0.5
                                sound.Parent = genPart
                                sound:Play()
                                game:GetService("Debris"):AddItem(sound, 2)
                            end
                        end)
                    end
                end
            end
        end
        
        -- Actualizar estado
        generatorStates[generator].lastProgress = currentProgress
        generatorStates[generator].lastCheck = tick()
    end)
end

--seccion full break generator
KillerTab:CreateToggle({
    Name = "Full Break Generator",
    CurrentValue = false,
    Callback = function(v)
        fullBreakEnabled = v
        
        if v then
            -- Conectar al evento de daño en los generadores
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name:lower():find("generator") then
                    setupGeneratorMonitor(obj)
                end
            end
            
            -- Monitorear nuevos generadores
            local descAdded
            descAdded = Workspace.DescendantAdded:Connect(function(obj)
                if obj:IsA("Model") and obj.Name:lower():find("generator") then
                    setupGeneratorMonitor(obj)
                end
            end)
            
            breakConnection = descAdded
            
            Rayfield:Notify({
                Title = "Full Break Activado",
                Content = "Patea generadores para romperlos completamente",
                Duration = 3
            })
            
        else
            -- Limpiar
            if breakConnection then
                breakConnection:Disconnect()
                breakConnection = nil
            end
            generatorStates = {}
        end
    end
})

-- Función modificada para forzar progreso a 0% al patear
function setupGeneratorMonitor(generator)
    if generatorStates[generator] then return end
    
    generatorStates[generator] = true
    
    -- Buscar el script de progreso del generador
    local function findProgressScript(model)
        for _, descendant in ipairs(model:GetDescendants()) do
            if descendant:IsA("Script") or descendant:IsA("LocalScript") then
                if descendant.Name:lower():find("progress") or 
                   descendant.Name:lower():find("repair") or
                   (descendant.Source and descendant.Source:lower():find("progreso")) then
                    return descendant
                end
            end
        end
        return nil
    end
    
    -- Buscar y modificar el evento de daño
    local function hookDamageEvent()
        -- Buscar cualquier RemoteEvent o BindableEvent relacionado con daño
        for _, descendant in ipairs(generator:GetDescendants()) do
            if descendant:IsA("RemoteEvent") or descendant:IsA("BindableEvent") then
                if descendant.Name:lower():find("damage") or 
                   descendant.Name:lower():find("kick") or
                   descendant.Name:lower():find("hit") then
                    
                    local oldFireServer = descendant.FireServer
                    descendant.FireServer = function(self, ...)
                        local args = {...}
                        -- Verificar si es el killer pateando
                        if fullBreakEnabled and #args > 0 then
                            -- Buscar y reiniciar el progreso a 0%
                            local progressScript = findProgressScript(generator)
                            if progressScript then
                                -- Intentar acceder a la variable de progreso
                                pcall(function()
                                    -- Diferentes formas de buscar el progreso
                                    for _, scriptPart in ipairs(progressScript:GetDescendants()) do
                                        if scriptPart:IsA("ModuleScript") then
                                            local module = require(scriptPart)
                                            if module and module.progress then
                                                module.progress = 0
                                            end
                                        end
                                    end
                                    
                                    -- También buscar variables directamente
                                    local src = progressScript.Source
                                    if src:find("progress") or src:find("Progreso") then
                                        -- Intentar encontrar y resetear el valor
                                        local progressValue = getfenv(progressScript).progress or 
                                                               getfenv(progressScript).Progreso or
                                                               getfenv(progressScript).repairProgress
                                        if progressValue and type(progressValue) == "number" then
                                            if getfenv(progressScript).progress then
                                                getfenv(progressScript).progress = 0
                                            elseif getfenv(progressScript).Progreso then
                                                getfenv(progressScript).Progreso = 0
                                            elseif getfenv(progressScript).repairProgress then
                                                getfenv(progressScript).repairProgress = 0
                                            end
                                        end
                                    end
                                end)
                            end
                        end
                        return oldFireServer(self, ...)
                    end
                end
            end
        end
    end
    
    -- También monitorear el progreso directamente
    local progressScript = findProgressScript(generator)
    if progressScript then
        local meta = getrawmetatable(progressScript)
        if meta and meta.__index then
            local oldIndex = meta.__index
            setreadonly(meta, false)
            meta.__index = newcclosure(function(self, key)
                local result = oldIndex(self, key)
                if fullBreakEnabled and (key == "progress" or key == "Progreso" or key == "repairProgress" or key == "repairprogress") then
                    -- Siempre devolver 0 si el killer pateó recientemente
                    return 0
                end
                return result
            end)
            setreadonly(meta, true)
        end
    end
    
    hookDamageEvent()
end

-- ============================================
-- PESTAÑA GRAPHICS
-- ============================================
local GraphicsTab = Window:CreateTab("Graphics")

-- Sección Optimization
GraphicsTab:CreateSection("Optimization")

GraphicsTab:CreateToggle({
    Name = "Low Graphics",
    CurrentValue = false,
    Flag = "NoShadows",
    Callback = function(s) 
        lowGraphicsEnabled = s
        if s then 
            originalShadows = Lighting.GlobalShadows
            applySimpleLowGraphics()
            Rayfield:Notify({
                Title = "Shadows Desactivadas",
                Content = "Mejor rendimiento activado",
                Duration = 2
            })
        else 
            restoreSimpleGraphics()
            Rayfield:Notify({
                Title = "Shadows Activadas",
                Content = "Calidad gráfica restaurada",
                Duration = 2
            })
        end
    end
})

-- ============================================
-- PESTAÑA MISC
-- ============================================
local MiscTab = Window:CreateTab("Misc")

-- Sección Utilities
MiscTab:CreateSection("Utilities")

MiscTab:CreateButton({
    Name = "Limpiar Todo",
    Callback = function()
        stopESPLoop()
        stopGeneratorESPLoop()
        stopSpeedBoostWatcher()
        stopGeneratorBoostWatcher()
        stopPerfectSkillCheck()
        stopNoSkillCheck()
        
        Rayfield:Notify({
            Title = "Limpieza Completada",
            Content = "Todos los hacks han sido desactivados",
            Duration = 3
        })
    end
})

-- ============================================
-- INICIALIZACIÓN DEL SISTEMA
-- ============================================

-- Observadores de jugadores
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LP then
        watchPlayer(p)
    end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LP then
        watchPlayer(p)
        task.wait(0.5)
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end
end)

Players.PlayerRemoving:Connect(function(p)
    unwatchPlayer(p)
end)

-- Conexión de personaje
LP.CharacterAdded:Connect(function(char)
    task.wait(0.2)
    applySpeedBoost()
    if genBoostEnabled then
        applyGeneratorBoost()
    end
end)

-- Cargar configuración y notificar
task.spawn(function()
    task.wait(2)
    Rayfield:LoadConfiguration()
    Rayfield:Notify({
        Title = "LoreOnTop",
        Content = "Script cargado y optimizado",
        Duration = 5,
        Image = "rbxassetid://4483345998"
    })
end)
