local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Servicios
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer

-- Variables ESP
local playerESPEnabled = false
local nametagsEnabled = false 
local showDistance = false
local maxDistance = 500
local hitboxExpanderEnabled = false
local hitboxMultiplier = 1.5
local hitboxTransparency = 0.9

-- Colores
local survivorColor = Color3.fromRGB(0, 255, 0)
local killerColor = Color3.fromRGB(255, 0, 0)
local spectatorColor = Color3.fromRGB(255, 255, 255)
local lobbyColor = Color3.fromRGB(200, 200, 200)
local generatorColor = Color3.fromRGB(0, 170, 255)

-- Cache
local playerCache = {}
local connections = {}
local espObjects = {}

-- Funciones auxiliares
local function alive(obj)
    return obj and obj.Parent ~= nil
end

local function validPart(p)
    return p and p:IsA("BasePart") and alive(p)
end

local function dist(a, b)
    return (a - b).Magnitude
end

local function clamp(n, lo, hi)
    if n < lo then return lo elseif n > hi then return hi else return n end
end

local function firstBasePart(inst)
    if not alive(inst) then return nil end
    if inst:IsA("BasePart") then return inst end
    if inst:IsA("Model") then
        if inst.PrimaryPart and inst.PrimaryPart:IsA("BasePart") and alive(inst.PrimaryPart) then
            return inst.PrimaryPart
        end
        local p = inst:FindFirstChildWhichIsA("BasePart", true)
        if validPart(p) then return p end
    end
    return nil
end

-- Billboard
local function makeBillboard(text, color3, parent)
    if not parent then return nil end
    
    local existing = parent:FindFirstChild("ESP_Tag")
    if existing then
        local label = existing:FindFirstChild("Label")
        if label then
            label.Text = text
            label.TextColor3 = color3
        end
        existing.Enabled = true
        return existing
    end
    
    local g = Instance.new("BillboardGui")
    g.Name = "ESP_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 200, 0, 36)
    g.StudsOffset = Vector3.new(0, 3, 0)
    g.Enabled = true
    g.Parent = parent
    
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1, 1, 1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0, 0, 0)
    l.Parent = g
    
    table.insert(espObjects, g)
    
    return g
end

-- Highlight
local function ensureHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    local hl = model:FindFirstChild("ESP_Highlight")
    if not hl then
        local success, result = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "ESP_Highlight"
            h.Adornee = model
            h.FillTransparency = 0.5
            h.OutlineTransparency = 0.2
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.FillColor = color
            h.OutlineColor = color
            h.Parent = model
            return h
        end)
        if success then 
            hl = result
            table.insert(espObjects, hl)
        else 
            return nil 
        end
    else
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.5
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
    end
    return hl
end

local function clearHighlight(model)
    if model and model:FindFirstChild("ESP_Highlight") then
        local hl = model.ESP_Highlight
        hl:Destroy()
        for i, obj in ipairs(espObjects) do
            if obj == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

-- Función para obtener rol
local function getRole(p)
    if not p then return "Lobby" end
    local team = p.Team
    if not team then return "Lobby" end
    local teamName = team.Name:lower()
    if teamName:find("killer") then
        return "Killer"
    elseif teamName:find("survivor") then
        return "Survivor"
    end
    return "Lobby"
end

-- Función para verificar espectador
local function isSpectator(p)
    if not p then return true end
    if not p.Character then return true end
    
    local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return true end
    
    return p:GetAttribute("Spectator") == true
end

-- Función para determinar si está en lobby
local function isInLobby(p)
    if not p then return true end
    if not p.Character then return true end
    
    local hrp = p.Character:FindFirstChild("HumanoidRootPart")  
    if hrp then
        local pos = hrp.Position
        if pos.Y < -100 then
            return true
        end
    end
    
    return getRole(p) == "Lobby"
end

-- Función para obtener color
local function getPlayerColor(p)
    if isInLobby(p) then
        return lobbyColor
    elseif isSpectator(p) then
        return spectatorColor
    elseif getRole(p) == "Killer" then
        return killerColor
    else
      return survivorColor
    end
end

-- ============================================
-- SISTEMA ESP PARA JUGADORES
-- ============================================

local espLoopConn = nil
local lastESPUpdate = 0
local ESP_UPDATE_INTERVAL = 0.08  -- Más rápido para mejor actualización

local function cleanPlayerESP(p)
    if not p then return end
    
    if p.Character then
        clearHighlight(p.Character)
        local head = p.Character:FindFirstChild("Head")
        if head and head:FindFirstChild("ESP_Tag") then
            head.ESP_Tag:Destroy()
        end
    end
    
    if playerCache[p] then
        playerCache[p] = nil
    end
end

local function applyOnePlayerESP(p)
    if p == LP then return end
    
    local character = p.Character
    if not (character and alive(character)) then
        cleanPlayerESP(p)
        return
    end
    
    local color = getPlayerColor(p)
    
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    
    if playerESPEnabled or nametagsEnabled then
        if playerESPEnabled then
            local hl = ensureHighlight(character, color)
            if hl then
                hl.Enabled = true
            end
        else
            clearHighlight(character)
        end
        
        if nametagsEnabled and validPart(head) then
            local text = p.Name
            
            -- Verificar si debemos mostrar distancia
            local shouldShowDistance = showDistance and not isSpectator(p) and not isInLobby(p)
            local isWithinDistance = true
            
            if shouldShowDistance and hrp and LP.Character and LP.Character.Parent then
                local myHrp = LP.Character:FindFirstChild("HumanoidRootPart")
                if myHrp and myHrp.Parent then
                    local distance = math.floor((hrp.Position - myHrp.Position).Magnitude)
                    
                    if distance <= maxDistance then
                        text = text .. " [" .. distance .. "m]"
                    else
                        -- Si está fuera de rango, no mostrar ESP
                        isWithinDistance = false
                        if head:FindFirstChild("ESP_Tag") then
                            head.ESP_Tag.Enabled = false
                        end
                        if playerESPEnabled then
                            clearHighlight(character)
                        end
                    end
                end
            end
            
            -- Solo mostrar ESP si está dentro del rango de distancia
            if isWithinDistance then
                local tag = makeBillboard(text, color, head)
                if tag then
                    tag.Enabled = true
                    tag.Adornee = head
                end
            end
        elseif head and head:FindFirstChild("ESP_Tag") then
            if not nametagsEnabled then
                head.ESP_Tag.Enabled = false
            end
        end
        
        if not playerCache[p] then 
            playerCache[p] = {
                lastUpdate = tick(),
                character = character
            }
        end
        playerCache[p].lastUpdate = tick()
    else
        cleanPlayerESP(p)
    end
end

local updateQueue = {}
local isProcessing = false

local function processUpdateQueue()
    if isProcessing then return end
    isProcessing = true
    
    local processed = 0
    local maxPerFrame = 5
    
    while #updateQueue > 0 and processed < maxPerFrame do
        local player = table.remove(updateQueue, 1)
        if player and player.Parent then
            applyOnePlayerESP(player)
            processed = processed + 1
        end
    end
    
    isProcessing = false
end

local function cleanupFarPlayers()
    if not (playerESPEnabled or nametagsEnabled) then return end
    if not LP.Character then return end
    
    local myHrp = LP.Character:FindFirstChild("HumanoidRootPart")
    if not myHrp then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            
            if hrp then
                local distance = (hrp.Position - myHrp.Position).Magnitude
                
                -- Si está fuera del rango máximo y showDistance está activado
                if showDistance and distance > maxDistance then
                    cleanPlayerESP(player)
                end
            end
        end
    end
end

local function startESPLoop()
    if espLoopConn then 
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    espLoopConn = RunService.Heartbeat:Connect(function(deltaTime)
        if not (playerESPEnabled or nametagsEnabled) then return end
        
        local now = tick()
        if now - lastESPUpdate < ESP_UPDATE_INTERVAL then 
            processUpdateQueue()
            cleanupFarPlayers()  -- Limpiar jugadores lejanos
            return 
        end
        lastESPUpdate = now
        
        updateQueue = {}
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LP then
                table.insert(updateQueue, player)
            end
        end
        
        processUpdateQueue()
        cleanupFarPlayers()  -- Limpiar jugadores lejanos
    end)
end

local function stopESPLoop()
    if espLoopConn then
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP then
            cleanPlayerESP(player)
        end
    end
    
    for _, obj in ipairs(espObjects) do
        if obj and obj.Parent then
            pcall(function() obj:Destroy() end)
        end
    end
    espObjects = {}
    playerCache = {}
    updateQueue = {}
end

local function forceUpdateAllPlayers()
    if not (playerESPEnabled or nametagsEnabled) then return end
    
    updateQueue = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP then
            table.insert(updateQueue, player)
            applyOnePlayerESP(player)
        end
    end
    cleanupFarPlayers()  -- Limpiar jugadores lejanos también
end

local function watchPlayer(p)
    if p == LP then return end
    if connections[p] then return end
    
    local playerConns = {}
    
    table.insert(playerConns, p.CharacterAdded:Connect(function(character)
        task.wait(0.3)
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end))
    
    table.insert(playerConns, p:GetPropertyChangedSignal("Team"):Connect(function()
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end))
    
    table.insert(playerConns, p:GetAttributeChangedSignal("Spectator"):Connect(function()
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end))
    
    if p.Character then
        task.spawn(function()
            task.wait(0.3)
            if playerESPEnabled or nametagsEnabled then
                applyOnePlayerESP(p)
            end
        end)
    end
    
    connections[p] = playerConns
end

local function unwatchPlayer(p)
    if connections[p] then
        for _, conn in ipairs(connections[p]) do
            pcall(function() conn:Disconnect() end)
        end
        connections[p] = nil
    end
    
    cleanPlayerESP(p)
    playerCache[p] = nil
end

-- ============================================
-- SISTEMA ESP PARA GENERATORS
-- ============================================
local generatorESPEnabled = false
local generatorLoopConn = nil
local generatorCache = {}

local function ensureGeneratorHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    local hl = model:FindFirstChild("Generator_Highlight")
    if not hl then
        local success, result = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "Generator_Highlight"
            h.Adornee = model
            h.FillTransparency = 0.7
            h.OutlineTransparency = 0.2
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.FillColor = color
            h.OutlineColor = color
            h.Parent = model
            return h
        end)
        if success then 
            hl = result
            table.insert(espObjects, hl)
        else 
            return nil 
        end
    else
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
    end
    return hl
end

local function clearGeneratorHighlight(model)
    if model and model:FindFirstChild("Generator_Highlight") then
        local hl = model.Generator_Highlight
        hl:Destroy()
        for i, obj in ipairs(espObjects) do
            if obj == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

local function getGeneratorProgress(model)
    local progress = model:GetAttribute("RepairProgress") or 
                     model:GetAttribute("Progress") or 
                     model:GetAttribute("CurrentProgress") or 0
    
    if progress <= 1 then
        progress = progress * 100
    end
    
    return math.clamp(progress, 0, 100)
end

local function findGenerators()
    local generators = {}
    
    local searchLocations = {
        Workspace,
        Workspace:FindFirstChild("Map"),
        Workspace:FindFirstChild("Map1"),
        Workspace:FindFirstChild("Generators"),
        Workspace:FindFirstChild("Props")
    }
    
    for _, location in ipairs(searchLocations) do
        if location then
            for _, obj in ipairs(location:GetDescendants()) do
                if obj:IsA("Model") and (obj.Name:lower():find("generator") or 
                   obj.Name:lower():find("gen") or 
                   obj:GetAttribute("IsGenerator") == true) then
                    
                    local basePart = firstBasePart(obj)
                    if basePart then
                        generators[obj] = {
                            model = obj,
                            part = basePart,
                            lastCheck = tick()
                        }
                    end
                end
            end
        end
    end
    
    return generators
end

local function updateGeneratorESP()
    if not generatorESPEnabled then return end
    
    local generators = findGenerators()
    local now = tick()
    
    for model, data in pairs(generatorCache) do
        if not alive(model) or not generators[model] then
            clearGeneratorHighlight(model)
            if data.part and data.part:FindFirstChild("Generator_Tag") then
                data.part.Generator_Tag:Destroy()
            end
            generatorCache[model] = nil
        end
    end
    
    for model, genData in pairs(generators) do
        if now - (generatorCache[model] and generatorCache[model].lastUpdate or 0) > 0.5 then
            
            local progress = getGeneratorProgress(model)
            local color = generatorColor
            
            if progress >= 100 then
                color = Color3.fromRGB(0, 255, 0)
            elseif progress >= 75 then
                color = Color3.fromRGB(0, 200, 100)
            elseif progress >= 50 then
                color = Color3.fromRGB(255, 255, 0)
            elseif progress >= 25 then
                color = Color3.fromRGB(255, 165, 0)
            else
                color = Color3.fromRGB(255, 50, 50)
            end
            
            local hl = ensureGeneratorHighlight(model, color)
            if hl then
                hl.Enabled = true
            end
            
            local part = genData.part
            if part then
                local existingTag = part:FindFirstChild("Generator_Tag")
                if existingTag then
                    existingTag:Destroy()
                end
                
                local bb = Instance.new("BillboardGui")
                bb.Name = "Generator_Tag"
                bb.AlwaysOnTop = true
                bb.Size = UDim2.new(0, 150, 0, 40)
                bb.StudsOffset = Vector3.new(0, 5, 0)
                bb.Enabled = true
                bb.Parent = part
                
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.BackgroundTransparency = 1
                label.Size = UDim2.new(1, 0, 1, 0)
                label.Font = Enum.Font.GothamBold
                label.Text = string.format("Generator: %.0f%%", progress)
                label.TextSize = 14
                label.TextColor3 = color
                label.TextStrokeTransparency = 0
                label.TextStrokeColor3 = Color3.new(0, 0, 0)
                label.Parent = bb
                
                table.insert(espObjects, bb)
            end
            
            generatorCache[model] = {
                model = model,
                part = genData.part,
                lastUpdate = now
            }
        end
    end
end

local function startGeneratorESPLoop()
    if generatorLoopConn then return end
    
    generatorLoopConn = RunService.Heartbeat:Connect(function()
        updateGeneratorESP()
    end)
end

local function stopGeneratorESPLoop()
    if generatorLoopConn then
        generatorLoopConn:Disconnect()
        generatorLoopConn = nil
    end
    
    for model, _ in pairs(generatorCache) do
        clearGeneratorHighlight(model)
        if model and model.PrimaryPart and model.PrimaryPart:FindFirstChild("Generator_Tag") then
            model.PrimaryPart.Generator_Tag:Destroy()
        end
    end
    generatorCache = {}
end

-- ============================================
-- SISTEMA SPEED BOOST (SURVIVOR & KILLER)
-- ============================================
local speedBoostEnabled = false
local speedBoostValue = 1.25
local killerSpeedEnabled = false
local killerSpeedValue = 1.3
local speedBoostConnection = nil

local function applySpeedBoost()
    if not LP.Character then return end
    
    local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local role = getRole(LP)
    local baseSpeed = 16
    
    if role == "Killer" and killerSpeedEnabled then
        humanoid.WalkSpeed = baseSpeed * killerSpeedValue
        humanoid:SetAttribute("speedboost", killerSpeedValue)
    elseif role == "Survivor" and speedBoostEnabled then
        humanoid.WalkSpeed = baseSpeed * speedBoostValue
        humanoid:SetAttribute("speedboost", speedBoostValue)
    else
        humanoid.WalkSpeed = baseSpeed
        humanoid:SetAttribute("speedboost", nil)
    end
end

local function startSpeedBoostWatcher()
    if speedBoostConnection then return end
    
    speedBoostConnection = RunService.Heartbeat:Connect(function()
        applySpeedBoost()
    end)
    
    applySpeedBoost()
end

local function stopSpeedBoostWatcher()
    if speedBoostConnection then
        speedBoostConnection:Disconnect()
        speedBoostConnection = nil
    end
    
    if LP.Character then
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 16
            humanoid:SetAttribute("speedboost", nil)
        end
    end
end

-- ============================================
-- SISTEMA GENERATOR BOOST
-- ============================================
local genBoostEnabled = false
local genBoostMultiplier = 1.05
local genBoostConnection = nil
local originalAttributes = {}

local function applyGeneratorBoost()
    if not genBoostEnabled or not LP.Character then return end
    
    if not originalAttributes.repairboost then
        originalAttributes.repairboost = LP.Character:GetAttribute("repairboost") or 1.0
        originalAttributes.GroupProject = LP.Character:GetAttribute("GroupProject") or 0
        originalAttributes.gp_applied_by = LP.Character:GetAttribute("gp_applied_by") or 0
    end
    
    pcall(function()
        LP.Character:SetAttribute("repairboost", genBoostMultiplier)
        LP.Character:SetAttribute("GroupProject", 2)
        LP.Character:SetAttribute("gp_applied_by", 2717078872)
        
        local repairSpeed = LP.Character:FindFirstChild("RepairSpeed")
        if not repairSpeed then
            repairSpeed = Instance.new("NumberValue")
            repairSpeed.Name = "RepairSpeed"
            repairSpeed.Value = genBoostMultiplier
            repairSpeed.Parent = LP.Character
        else
            repairSpeed.Value = genBoostMultiplier
        end
    end)
end

local function removeGeneratorBoost()
    if not LP.Character then return end
    
    pcall(function()
        if originalAttributes.repairboost then
            LP.Character:SetAttribute("repairboost", originalAttributes.repairboost)
        else
            LP.Character:SetAttribute("repairboost", 1.0)
        end
        
        if originalAttributes.GroupProject then
            LP.Character:SetAttribute("GroupProject", originalAttributes.GroupProject)
        else
            LP.Character:SetAttribute("GroupProject", 0)
        end
        
        if originalAttributes.gp_applied_by then
            LP.Character:SetAttribute("gp_applied_by", originalAttributes.gp_applied_by)
        else
            LP.Character:SetAttribute("gp_applied_by", 0)
        end
        
        local repairSpeed = LP.Character:FindFirstChild("RepairSpeed")
        if repairSpeed then
            repairSpeed:Destroy()
        end
    end)
end

local function startGeneratorBoostWatcher()
    if genBoostConnection then return end
    
    genBoostConnection = RunService.Heartbeat:Connect(function()
        if genBoostEnabled then
            applyGeneratorBoost()
        end
    end)
    
    applyGeneratorBoost()
end

local function stopGeneratorBoostWatcher()
    if genBoostConnection then
        genBoostConnection:Disconnect()
        genBoostConnection = nil
    end
    
    removeGeneratorBoost()
end

-- ============================================
-- SISTEMA PERFECT SKILLCHECK
-- ============================================
local perfectSkillEnabled = false
local perfectSkillConnection = nil

local function findSkillCheckUI()
    local playerGui = LP:FindFirstChild("PlayerGui")
    if not playerGui then return nil end
    
    for _, screenGui in ipairs(playerGui:GetChildren()) do
        if screenGui:IsA("ScreenGui") then
            for _, obj in ipairs(screenGui:GetDescendants()) do
                if obj.Name:lower():find("skillcheck") or 
                   obj.Name:lower():find("skill") and obj:IsA("Frame") then
                    return obj
                end
            end
        end
    end
    return nil
end

local function getSkillCheckComponents(skillCheckUI)
    local bar, zone, pointer
    
    for _, child in ipairs(skillCheckUI:GetDescendants()) do
        if child:IsA("Frame") then
            local size = child.AbsoluteSize
            if size.X > 200 and size.Y < 50 then
                bar = child
            elseif child.Name:lower():find("zone") or child.Name:lower():find("perfect") then
                zone = child
            elseif child.Name:lower():find("pointer") or child.Name:lower():find("marker") then
                pointer = child
            end
        end
    end
    
    return bar, zone, pointer
end

local function executePerfectSkillCheck()
    if not perfectSkillEnabled then return end
    
    local skillCheckUI = findSkillCheckUI()
    if not skillCheckUI then return end
    
    local bar, zone, pointer = getSkillCheckComponents(skillCheckUI)
    if not (bar and zone and pointer) then return end
    
    local zoneCenter = zone.AbsolutePosition.X + (zone.AbsoluteSize.X / 2)
    local barStart = bar.AbsolutePosition.X
    local barWidth = bar.AbsoluteSize.X
    
    if barWidth > 0 then
        local perfectPosition = (zoneCenter - barStart) / barWidth
        perfectPosition = math.clamp(perfectPosition, 0, 1)
        
        pcall(function()
            if pointer:IsA("Frame") then
                pointer.Position = UDim2.new(perfectPosition, 0, pointer.Position.Y.Scale, pointer.Position.Y.Offset)
            end
        end)
        
        local args = {
            [1] = perfectPosition,
            [2] = true
        }
        
        pcall(function()
            for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do
                if remote:IsA("RemoteEvent") and (remote.Name:lower():find("skill") or remote.Name:lower():find("check")) then
                    remote:FireServer(args)
                    break
                end
            end
            
            LP.Character:SetAttribute("LastSkillCheck", perfectPosition)
            LP.Character:SetAttribute("SkillCheckPerfect", true)
        end)
    end
end

local function startPerfectSkillCheck()
    if perfectSkillConnection then return end
    
    perfectSkillConnection = RunService.Heartbeat:Connect(function()
        executePerfectSkillCheck()
    end)
end

local function stopPerfectSkillCheck()
    if perfectSkillConnection then
        perfectSkillConnection:Disconnect()
        perfectSkillConnection = nil
    end
end

-- ============================================
-- SISTEMA NO SKILLCHECK
-- ============================================
local noSkillCheckEnabled = false
local noSkillCheckConnection = nil

local function removeSkillChecks()
    if not noSkillCheckEnabled then return end
    
    local playerGui = LP:FindFirstChild("PlayerGui")
    if not playerGui then return end
    
    for _, screenGui in ipairs(playerGui:GetChildren()) do
        if screenGui:IsA("ScreenGui") then
            for _, obj in ipairs(screenGui:GetDescendants()) do
                if obj.Name:lower():find("skillcheck") or 
                   obj.Name:lower():find("skill") and (obj:IsA("Frame") or obj:IsA("ImageLabel")) then
                    pcall(function() obj:Destroy() end)
                end
            end
        end
    end
    
    pcall(function()
        LP.Character:SetAttribute("SkipSkillCheck", true)
        LP.Character:SetAttribute("AutoCompleteSkillCheck", true)
    end)
end

local function startNoSkillCheck()
    if noSkillCheckConnection then return end
    
    noSkillCheckConnection = RunService.Heartbeat:Connect(function()
        removeSkillChecks()
    end)
    
    removeSkillChecks()
end

local function stopNoSkillCheck()
    if noSkillCheckConnection then
        noSkillCheckConnection:Disconnect()
        noSkillCheckConnection = nil
    end
    
    pcall(function()
        if LP.Character then
            LP.Character:SetAttribute("SkipSkillCheck", nil)
            LP.Character:SetAttribute("AutoCompleteSkillCheck", nil)
        end
    end)
end

-- ============================================
-- SISTEMA LOW GRAPHICS
-- ============================================
local lowGraphicsEnabled = false
local lowGraphicsConnection = nil
local originalSettings = {}

-- Función para aplicar Low Graphics
local function applyLowGraphics()
    if not lowGraphicsEnabled then return end
    
    pcall(function()
        -- 1. DESACTIVAR SOMBRAS
        Lighting.GlobalShadows = false
        
        -- 2. ELIMINAR NIEBLA/ATMOSFERA
        Lighting.FogEnd = 1000000
        Lighting.FogStart = 1000000
        
        if Lighting:FindFirstChild("Atmosphere") then
            Lighting.Atmosphere.Density = 0
            Lighting.Atmosphere.Offset = 100000
            Lighting.Atmosphere.Color = Color3.new(1, 1, 1)
        end
        
        -- 3. ELIMINAR EFECTOS DE POST-PROCESAMIENTO
        local effectsToDisable = {
            "BloomEffect",
            "BlurEffect", 
            "SunRaysEffect",
            "ColorCorrectionEffect",
            "DepthOfFieldEffect"
        }
        
        for _, effectName in ipairs(effectsToDisable) do
            local effect = Lighting:FindFirstChild(effectName)
            if effect then
                effect.Enabled = false
            end
        end
        
        -- 4. REDUCIR CALIDAD DE TEXTURAS Y MATERIALES
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                -- Desactivar sombras en partes
                part.CastShadow = false
                
                -- Cambiar materiales costosos por simples
                if part.Material == Enum.Material.Glass or 
                   part.Material == Enum.Material.Neon or
                   part.Material == Enum.Material.Foil then
                    part.Material = Enum.Material.SmoothPlastic
                end
                
                -- Reducir transparencia en partes transparentes
                if part.Transparency > 0.5 then
                    part.Transparency = 0.8
                end
            end
            
            -- 5. ELIMINAR PARTÍCULAS (GRANULADO/EFECTOS VISUALES)
            if part:IsA("ParticleEmitter") then
                part.Enabled = false
                part.Rate = 0
            end
            
            -- 6. ELIMINAR DECALS/STICKERS INNECESARIOS
            if part:IsA("Decal") then
                local texture = part.Texture:lower()
                if texture:find("noise") or texture:find("grain") or 
                   texture:find("dirt") or texture:find("scratch") then
                    part.Transparency = 1
                end
            end
            
            -- 7. DESACTIVAR FUENTES DE LUZ DINÁMICAS
            if part:IsA("PointLight") or part:IsA("SpotLight") or 
               part:IsA("SurfaceLight") then
                part.Enabled = false
            end
        end
        
        -- 8. CONFIGURAR RENDER SETTINGS
        local settings = game:GetService("Workspace"):FindFirstChild("CurrentCamera")
        if settings then
            -- Reducir calidad de renderizado
            settings.DepthOfField.Enabled = false
            settings.Bloom.Enabled = false
        end
        
        -- 9. ELIMINAR NUBES
        if Workspace:FindFirstChildOfClass("Clouds") then
            Workspace:FindFirstChildOfClass("Clouds"):Destroy()
        end
        
        -- 10. REDUCIR CALIDAD DE AGUA
        for _, water in ipairs(Workspace:GetDescendants()) do
            if water:IsA("Water") then
                water.Material = Enum.Material.SmoothPlastic
                water.Transparency = 0.7
            end
        end
    end)
end

-- Función para guardar configuraciones originales
local function saveOriginalSettings()
    originalSettings = {
        GlobalShadows = Lighting.GlobalShadows,
        FogEnd = Lighting.FogEnd,
        FogStart = Lighting.FogStart,
        Atmosphere = {}
    }
    
    -- Guardar configuración de Atmosphere si existe
    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        originalSettings.Atmosphere = {
            Density = atmosphere.Density,
            Offset = atmosphere.Offset,
            Color = atmosphere.Color
        }
    end
    
    -- Guardar efectos
    originalSettings.Effects = {}
    local effects = {"BloomEffect", "BlurEffect", "SunRaysEffect", "ColorCorrectionEffect", "DepthOfFieldEffect"}
    
    for _, effectName in ipairs(effects) do
        local effect = Lighting:FindFirstChild(effectName)
        if effect then
            originalSettings.Effects[effectName] = effect.Enabled
        end
    end
    
    -- Guardar configuraciones de partes
    originalSettings.Parts = {}
    for _, part in ipairs(Workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            originalSettings.Parts[part] = {
                CastShadow = part.CastShadow,
                Material = part.Material,
                Transparency = part.Transparency
            }
        elseif part:IsA("ParticleEmitter") then
            originalSettings.Parts[part] = {
                Enabled = part.Enabled,
                Rate = part.Rate
            }
        elseif part:IsA("PointLight") or part:IsA("SpotLight") or part:IsA("SurfaceLight") then
            originalSettings.Parts[part] = {
                Enabled = part.Enabled
            }
        end
    end
end

-- Función para restaurar configuraciones originales
local function restoreOriginalSettings()
    pcall(function()
        -- Restaurar Lighting
        Lighting.GlobalShadows = originalSettings.GlobalShadows or true
        Lighting.FogEnd = originalSettings.FogEnd or 1000
        Lighting.FogStart = originalSettings.FogStart or 0
        
        -- Restaurar Atmosphere
        local atmosphere = Lighting:FindFirstChild("Atmosphere")
        if atmosphere and originalSettings.Atmosphere then
            atmosphere.Density = originalSettings.Atmosphere.Density or 0.3
            atmosphere.Offset = originalSettings.Atmosphere.Offset or 0.25
            atmosphere.Color = originalSettings.Atmosphere.Color or Color3.new(1, 1, 1)
        end
        
        -- Restaurar efectos
        if originalSettings.Effects then
            for effectName, enabled in pairs(originalSettings.Effects) do
                local effect = Lighting:FindFirstChild(effectName)
                if effect then
                    effect.Enabled = enabled
                end
            end
        end
        
        -- Restaurar partes
        if originalSettings.Parts then
            for part, settings in pairs(originalSettings.Parts) do
                if part and part.Parent then
                    if part:IsA("BasePart") then
                        part.CastShadow = settings.CastShadow
                        part.Material = settings.Material
                        part.Transparency = settings.Transparency
                    elseif part:IsA("ParticleEmitter") then
                        part.Enabled = settings.Enabled
                        part.Rate = settings.Rate
                    elseif part:IsA("PointLight") or part:IsA("SpotLight") or part:IsA("SurfaceLight") then
                        part.Enabled = settings.Enabled
                    end
                end
            end
        end
        
        -- Restaurar Render Settings
        local settings = game:GetService("Workspace"):FindFirstChild("CurrentCamera")
        if settings then
            settings.DepthOfField.Enabled = true
            settings.Bloom.Enabled = true
        end
    end)
end

local function startLowGraphicsLoop()
    if lowGraphicsConnection then return end
    
    -- Guardar configuraciones originales
    saveOriginalSettings()
    
    -- Aplicar inmediatamente
    applyLowGraphics()
    
    -- Monitorear constantemente
    lowGraphicsConnection = RunService.Heartbeat:Connect(function()
        applyLowGraphics()
    end)
end

local function stopLowGraphicsLoop()
    if lowGraphicsConnection then
        lowGraphicsConnection:Disconnect()
        lowGraphicsConnection = nil
    end
    
    restoreOriginalSettings()
end

-- ============================================
-- VENTANA RAYFIELD (ORGANIZACIÓN PEDIDA)
-- ============================================
local Window = Rayfield:CreateWindow({
    Name = "LoreOnTop",
    LoadingTitle = "Violence District",
    LoadingSubtitle = "Hecho por kcha abuelas3000",
    ConfigurationSaving = {Enabled = true, FolderName = "ESP_Suite", FileName = "esp_config"},
    KeySystem = false
})

-- ============================================
-- PESTAÑA VISUAL (ESP)
-- ============================================
local VisualTab = Window:CreateTab("Visual")

-- Sección Player ESP
VisualTab:CreateSection("Player ESP")

VisualTab:CreateToggle({
    Name = "Players ESP",
    CurrentValue = false,
    Flag = "PlayerESP",
    Callback = function(s)
        playerESPEnabled = s
        if s or nametagsEnabled then
            startESPLoop()
            task.wait(0.1)
            forceUpdateAllPlayers()
        else
            stopESPLoop()
        end
    end
})

VisualTab:CreateToggle({
    Name = "Mostrar Nombres",
    CurrentValue = false,
    Flag = "Nametags",
    Callback = function(s)
        nametagsEnabled = s
        if s or playerESPEnabled then
            startESPLoop()
            task.wait(0.1)
            forceUpdateAllPlayers()
        else
            stopESPLoop()
        end
    end
})

VisualTab:CreateToggle({
  Name = "Mostrar Distancia",
  CurrentValue = showDistance,
  Flag = "showDistance",
  Callback = function(s)
    showDistance = s
    if playerESPEnabled or nametagsEnabled then
      forceUpdateAllPlayers()
    end
  end
})

VisualTab:CreateSlider({
    Name = "Distancia Máxima",
    Range = {50, 300},
    Increment = 10,
    Suffix = " studs",
    CurrentValue = maxDistance,
    Flag = "MaxDistance",
    Callback = function(v)
        maxDistance = v
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})


VisualTab:CreateButton({
    Name = "Forzar Actualización ESP",
    Callback = function()
        forceUpdateAllPlayers()
        Rayfield:Notify({
            Title = "ESP Actualizado",
            Content = "Todos los jugadores han sido actualizados",
            Duration = 2
        })
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Survivor",
    Color = survivorColor,
    Flag = "SurvivorCol",
    Callback = function(c) 
        survivorColor = c 
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Killer",
    Color = killerColor,
    Flag = "KillerCol",
    Callback = function(c) 
        killerColor = c 
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Lobby",
    Color = lobbyColor,
    Flag = "LobbyCol",
    Callback = function(c) 
        lobbyColor = c 
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateSlider({
    Name = "Intervalo de Actualización ESP",
    Range = {0.05, 3.00},
    Increment = 0.05,
    Suffix = " segundos",
    CurrentValue = ESP_UPDATE_INTERVAL,
    Flag = "UpdateInterval",
    Callback = function(v)
        ESP_UPDATE_INTERVAL = v
    end
})

-- Sección Generator ESP
VisualTab:CreateSection("Generator ESP")

VisualTab:CreateToggle({
    Name = "Generator ESP",
    CurrentValue = false,
    Flag = "GeneratorESP",
    Callback = function(s)
        generatorESPEnabled = s
        if s then 
            startGeneratorESPLoop() 
        else 
            stopGeneratorESPLoop() 
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Generator Color",
    Color = generatorColor,
    Flag = "GenCol",
    Callback = function(c) 
        generatorColor = c 
    end
})

-- ============================================
-- PESTAÑA SURVIVORS
-- ============================================
local SurvivorTab = Window:CreateTab("Survivors")

-- Sección Speed Boost
SurvivorTab:CreateSection("Speed Boost")

SurvivorTab:CreateToggle({
    Name = "Enable Speed Boost",
    CurrentValue = false,
    Flag = "SpeedBoostToggle",
    Callback = function(state)
        speedBoostEnabled = state
        if state then
            startSpeedBoostWatcher()
        else
            stopSpeedBoostWatcher()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Speed Multiplier",
    Range = {1.00, 2.00},
    Increment = 0.10,
    Suffix = "x",
    CurrentValue = speedBoostValue,
    Flag = "SpeedBoostValue",
    Callback = function(v)
        speedBoostValue = v
        if speedBoostEnabled and LP.Character then
            applySpeedBoost(LP.Character)
        end
    end
})

-- Sección Generator Boost
SurvivorTab:CreateSection("Generator Boost")

SurvivorTab:CreateToggle({
    Name = "Enable Generator Boost",
    CurrentValue = false,
    Flag = "GenBoostToggle",
    Callback = function(state)
        genBoostEnabled = state
        if state then
            startGeneratorBoostWatcher()
        else
            stopGeneratorBoostWatcher()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Repair Multiplier",
    Range = {1.00, 5.00},
    Increment = 0.05,
    Suffix = "x",
    CurrentValue = genBoostMultiplier,
    Flag = "GenBoostValue",
    Callback = function(value)
        genBoostMultiplier = value
        
        if genBoostEnabled then
            applyGeneratorBoost()
        end
    end
})

-- Sección SkillCheck
SurvivorTab:CreateSection("SkillCheck")

SurvivorTab:CreateToggle({
    Name = "Enable Perfect Skillcheck",
    CurrentValue = false,
    Callback = function(v)
        perfectSkillEnabled = v
        if v then startPerfectSkillCheck() else stopPerfectSkillCheck() end
    end
})

SurvivorTab:CreateToggle({
    Name = "Enable No Skillchecks",
    CurrentValue = false,
    Callback = function(v)
        if v then startNoSkillCheck() else stopNoSkillCheck() end
    end
})

-- Sección Healing
SurvivorTab:CreateSection("Healing")

SurvivorTab:CreateToggle({
    Name = "Insta Heal",
    CurrentValue = false,
    Callback = function(v)
        if v then
            -- Activar insta heal
            local char = LP.Character
            if char then
                char:SetAttribute("isHealing", true)
                char:SetAttribute("HealProgress", 100)
                char:SetAttribute("IsBeingHealed", true)
            end
        else
            -- Desactivar
            local char = LP.Character
            if char then
                char:SetAttribute("isHealing", nil)
                char:SetAttribute("HealProgress", nil)
                char:SetAttribute("IsBeingHealed", nil)
            end
        end
    end
})

-- Sección Anti-Ralentización
SurvivorTab:CreateSection("Anti-Ralentización")

SurvivorTab:CreateToggle({
    Name = "Anti-Ralentización",
    CurrentValue = false,
    Callback = function(v)
        if v then
            -- Activar anti-ralentización
            local char = LP.Character
            if char then
                char:SetAttribute("Immobile", false)
                
                -- Monitorear constantemente
                RunService.Heartbeat:Connect(function()
                    if char then
                        char:SetAttribute("Immobile", false)
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            humanoid.WalkSpeed = 16 * speedBoostValue
                        end
                    end
                end)
            end
        else
            -- Desactivar
            local char = LP.Character
            if char then
                char:SetAttribute("Immobile", nil)
            end
        end
    end
})

-- ============================================
-- PESTAÑA KILLERS
-- ============================================
local KillerTab = Window:CreateTab("Killers")

-- Sección Speed Boost Killer
KillerTab:CreateSection("Speed Boost")

KillerTab:CreateToggle({
    Name = "Killer Speed Boost",
    CurrentValue = false,
    Callback = function(v)
        killerSpeedEnabled = v
        applySpeedBoost()
    end
})

KillerTab:CreateSlider({
    Name = "Killer Speed Multiplier",
    Range = {1.0, 2.0},
    Increment = 0.1,
    CurrentValue = killerSpeedValue,
    Callback = function(v)
        killerSpeedValue = v
        if killerSpeedEnabled then
            applySpeedBoost()
        end
    end
})

-- Sección Anti-Stun
KillerTab:CreateSection("Anti-Stun")

KillerTab:CreateToggle({
    Name = "Anti-Stun",
    CurrentValue = false,
    Callback = function(v)
        if v then
            -- Activar anti-stun
            local char = LP.Character
            if char then
                char:SetAttribute("IsStunned", false)
                
                -- Monitorear constantemente para evitar stun
                RunService.Heartbeat:Connect(function()
                    if char then
                        char:SetAttribute("IsStunned", false)
                    end
                end)
            end
        else
            -- Desactivar
            local char = LP.Character
            if char then
                char:SetAttribute("IsStunned", nil)
            end
        end
    end
})

-- Sección Hitbox Expander (Invisible)
KillerTab:CreateSection("Hitbox Expander")

-- Función para crear hitbox invisible
local function createInvisibleHitbox(character, multiplier)
    if not character or not character.Parent then return end
    
    -- Buscar si ya existe una hitbox
    local existingHitbox = character:FindFirstChild("InvisibleHitbox")
    if existingHitbox then
        existingHitbox:Destroy()
    end
    
    -- Crear una parte invisible para la hitbox
    local hitboxPart = Instance.new("Part")
    hitboxPart.Name = "InvisibleHitbox"
    hitboxPart.Anchored = false
    hitboxPart.CanCollide = false
    hitboxPart.Transparency = hitboxTransparency  -- Usar la variable de transparencia
    hitboxPart.Color = Color3.fromRGB(255, 0, 0)  -- Rojo pero casi transparente
    hitboxPart.Material = Enum.Material.Neon
    
    -- Usar el tamaño del torso o humanoidrootpart como base
    local basePart = character:FindFirstChild("HumanoidRootPart") or 
                     character:FindFirstChild("Torso") or 
                     character:FindFirstChild("UpperTorso")
    
    if basePart then
        hitboxPart.Size = basePart.Size * multiplier
        hitboxPart.CFrame = basePart.CFrame
        
        -- Conectar para que siga al personaje
        local weld = Instance.new("Weld")
        weld.Part0 = basePart
        weld.Part1 = hitboxPart
        weld.C0 = CFrame.new(0, 0, 0)
        weld.Parent = hitboxPart
    else
        hitboxPart.Size = Vector3.new(4, 6, 2) * multiplier
        hitboxPart.CFrame = character:GetPivot()
    end
    
    -- Configurar propiedades para que sea solo hitbox
    hitboxPart.CastShadow = false
    hitboxPart.Locked = true
    hitboxPart.Parent = character
    
    return hitboxPart
end

KillerTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = false,
    Callback = function(v)
        hitboxExpanderEnabled = v
        if v then
            -- Crear hitbox invisible para todos los survivors
            for _, player in ipairs(Players:GetPlayers()) do
                if getRole(player) == "Survivor" and player.Character then
                    createInvisibleHitbox(player.Character, hitboxMultiplier)
                end
            end
            
            -- Conectar para cuando nuevos survivors aparezcan
            Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function(character)
                    task.wait(1)  -- Esperar a que cargue
                    if hitboxExpanderEnabled and getRole(player) == "Survivor" then
                        createInvisibleHitbox(character, hitboxMultiplier)
                    end
                end)
            end)
            
            -- Conectar para survivors existentes
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LP then
                    player.CharacterAdded:Connect(function(character)
                        task.wait(1)
                        if hitboxExpanderEnabled and getRole(player) == "Survivor" then
                            createInvisibleHitbox(character, hitboxMultiplier)
                        end
                    end)
                end
            end
        else
            -- Eliminar todas las hitbox invisibles
            for _, player in ipairs(Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("InvisibleHitbox") then
                    player.Character.InvisibleHitbox:Destroy()
                end
            end
        end
    end
})

KillerTab:CreateSlider({
    Name = "Hitbox Size Multiplier",
    Range = {1.0, 5.0},
    Increment = 0.1,
    CurrentValue = hitboxMultiplier,
    Callback = function(v)
        hitboxMultiplier = v
        if hitboxExpanderEnabled then
            -- Actualizar tamaño de todas las hitbox existentes
            for _, player in ipairs(Players:GetPlayers()) do
                if getRole(player) == "Survivor" and player.Character then
                    local hitbox = player.Character:FindFirstChild("InvisibleHitbox")
                    if hitbox then
                        local basePart = player.Character:FindFirstChild("HumanoidRootPart") or 
                                       player.Character:FindFirstChild("Torso")
                        if basePart then
                            hitbox.Size = basePart.Size * hitboxMultiplier
                        end
                    end
                end
            end
        end
    end
})

KillerTab:CreateSlider({
    Name = "Hitbox Transparency",
    Range = {0.1, 1.0},
    Increment = 0.1,
    CurrentValue = hitboxTransparency,
    Callback = function(v)
        hitboxTransparency = v
        if hitboxExpanderEnabled then
            -- Actualizar transparencia de todas las hitbox
            for _, player in ipairs(Players:GetPlayers()) do
                if getRole(player) == "Survivor" and player.Character then
                    local hitbox = player.Character:FindFirstChild("InvisibleHitbox")
                    if hitbox then
                        hitbox.Transparency = hitboxTransparency
                        
                        if hitboxTransparency >= 0.9 then
                            hitbox.Transparency = 1
                        end
                    end
                end
            end
        end
    end
})

-- Sección Full Break Motor
KillerTab:CreateSection("Full Break Motor")

local fullBreakEnabled = false
local breakConnection = nil
local generatorStates = {}

local function setupGeneratorMonitor(generator)
    if generatorStates[generator] then return end
    
    generatorStates[generator] = {
        lastProgress = generator:GetAttribute("RepairProgress") or 1,
        lastCheck = tick()
    }
    
    -- Monitorear cambios en el atributo RepairProgress
    generator:GetAttributeChangedSignal("RepairProgress"):Connect(function()
        if not fullBreakEnabled or getRole(LP) ~= "Killer" then return end
        
        local currentProgress = generator:GetAttribute("RepairProgress") or 1
        local lastProgress = generatorStates[generator].lastProgress
        
        if currentProgress < lastProgress then
          
            if tick() - generatorStates[generator].lastCheck < 2 then
              
                if LP.Character then
                    local hrp = LP.Character:FindFirstChild("HumanoidRootPart")
                    local genPart = generator.PrimaryPart or generator:FindFirstChildWhichIsA("BasePart")
                    
                    if hrp and genPart and (hrp.Position - genPart.Position).Magnitude < 15 then
                      
                        task.wait(0.1)
                        
                        pcall(function()
                            generator:SetAttribute("RepairProgress", 0)
                            generator:SetAttribute("ProgressBar", 0)
                            
                            -- Efecto visual/sonoro opcional
                            if genPart then
                                local sound = Instance.new("Sound")
                                sound.SoundId = "rbxassetid://9114822715"
                                sound.Volume = 0.5
                                sound.Parent = genPart
                                sound:Play()
                                game:GetService("Debris"):AddItem(sound, 2)
                            end
                        end)
                    end
                end
            end
        end
        
        -- Actualizar estado
        generatorStates[generator].lastProgress = currentProgress
        generatorStates[generator].lastCheck = tick()
    end)
end

KillerTab:CreateToggle({
    Name = "Full Break Motor",
    CurrentValue = false,
    Callback = function(v)
        fullBreakEnabled = v
        
        if v then
            -- Configurar monitores para generadores existentes
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name:lower():find("generator") then
                    setupGeneratorMonitor(obj)
                end
            end
            
            -- Monitorear nuevos generadores
            local descAdded
            descAdded = Workspace.DescendantAdded:Connect(function(obj)
                if obj:IsA("Model") and obj.Name:lower():find("generator") then
                    setupGeneratorMonitor(obj)
                end
            end)
            
            breakConnection = descAdded
            
            Rayfield:Notify({
                Title = "Full Break Activado",
                Content = "Patea generadores para romperlos completamente",
                Duration = 3
            })
            
        else
            -- Limpiar
            if breakConnection then
                breakConnection:Disconnect()
                breakConnection = nil
            end
            generatorStates = {}
            
            Rayfield:Notify({
                Title = "Full Break Desactivado",
                Content = "Daño normal activado",
                Duration = 3
            })
        end
    end
})

-- ============================================
-- PESTAÑA GRAPHICS
-- ============================================
local GraphicsTab = Window:CreateTab("Graphics")

-- Sección Optimization
GraphicsTab:CreateSection("Optimization")

GraphicsTab:CreateToggle({
    Name = "Low Graphics",
    CurrentValue = false,
    Flag = "LowGraphics",
    Callback = function(s) 
        lowGraphicsEnabled = s
        if s then 
            startLowGraphicsLoop()
            Rayfield:Notify({
                Title = "Low Graphics Activado",
                Content = "Juego optimizado para mejor rendimiento",
                Duration = 3
            })
        else 
            stopLowGraphicsLoop()
            Rayfield:Notify({
                Title = "Low Graphics Desactivado",
                Content = "Calidad gráfica restaurada",
                Duration = 3
            })
        end
    end
})

GraphicsTab:CreateButton({
    Name = "Forzar Optimización",
    Callback = function()
        applyLowGraphics()
        Rayfield:Notify({
            Title = "Optimizado",
            Content = "Graphics optimizados manualmente",
            Duration = 2
        })
    end
})

-- ============================================
-- PESTAÑA MISC
-- ============================================
local MiscTab = Window:CreateTab("Misc")

-- Sección Utilities
MiscTab:CreateSection("Utilities")

local autoRespawnEnabled = false
MiscTab:CreateToggle({
    Name = "Auto Respawn",
    CurrentValue = false,
    Callback = function(v)
        autoRespawnEnabled = v
    end
})

MiscTab:CreateButton({
    Name = "Limpiar Todo",
    Callback = function()
        stopESPLoop()
        stopGeneratorESPLoop()
        stopSpeedBoostWatcher()
        stopGeneratorBoostWatcher()
        stopPerfectSkillCheck()
        stopNoSkillCheck()
        stopNoFogLoop()
        stopNoShadowsLoop()
        
        Rayfield:Notify({
            Title = "Limpieza Completada",
            Content = "Todos los hacks han sido desactivados",
            Duration = 3
        })
    end
})

MiscTab:CreateButton({
    Name = "Recargar Script",
    Callback = function()
        Rayfield:Notify({
            Title = "Recargando",
            Content = "El script se recargará en 3 segundos",
            Duration = 3
        })
        task.wait(3)
        loadstring(game:HttpGet("https://raw.githubusercontent.com/tu-usuario/tu-repo/main/script.lua"))()
    end
})

-- ============================================
-- INICIALIZACIÓN DEL SISTEMA
-- ============================================

-- Observadores de jugadores
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LP then
        watchPlayer(p)
    end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LP then
        watchPlayer(p)
        task.wait(0.5)
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end
end)

Players.PlayerRemoving:Connect(function(p)
    unwatchPlayer(p)
end)

-- Conexión de personaje
LP.CharacterAdded:Connect(function(char)
    task.wait(0.2)
    applySpeedBoost()
    if genBoostEnabled then
        applyGeneratorBoost()
    end
end)

-- Cargar configuración y notificar
task.spawn(function()
    task.wait(2)
    Rayfield:LoadConfiguration()
    Rayfield:Notify({
        Title = "LoreOnTop",
        Content = "Script cargado y optimizado",
        Duration = 5,
        Image = "rbxassetid://4483345998"
    })
end)

-- Conectar cleanup
game:GetService("UserInputService").WindowFocusReleased:Connect(function()
    stopESPLoop()
    stopGeneratorESPLoop()
end)
