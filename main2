local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Servicios
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LP = Players.LocalPlayer

-- Variables ESP
local playerESPEnabled = false
local nametagsEnabled = false
local showDistance = false
local maxDistance = 500

-- Colores
local survivorColor = Color3.fromRGB(0, 255, 0)
local killerColor = Color3.fromRGB(255, 0, 0)
local spectatorColor = Color3.fromRGB(255, 255, 255)
local lobbyColor = Color3.fromRGB(200, 200, 200)
local generatorColor = Color3.fromRGB(0, 170, 255)  -- AÑADIDO: Color para generadores

-- Cache mejorado
local playerCache = {}
local connections = {}
local espObjects = {}

-- Funciones auxiliares
local function alive(obj)
    return obj and obj.Parent ~= nil
end

local function validPart(p)
    return p and p:IsA("BasePart") and alive(p)
end

local function dist(a, b)
    return (a - b).Magnitude
end

local function clamp(n, lo, hi)
    if n < lo then return lo elseif n > hi then return hi else return n end
end

local function firstBasePart(inst)
    if not alive(inst) then return nil end
    if inst:IsA("BasePart") then return inst end
    if inst:IsA("Model") then
        if inst.PrimaryPart and inst.PrimaryPart:IsA("BasePart") and alive(inst.PrimaryPart) then
            return inst.PrimaryPart
        end
        local p = inst:FindFirstChildWhichIsA("BasePart", true)
        if validPart(p) then return p end
    end
    return nil
end

-- Billboard optimizado
local function makeBillboard(text, color3, parent)
    if not parent then return nil end
    
    -- Verificar si ya existe
    local existing = parent:FindFirstChild("ESP_Tag")
    if existing then
        -- Actualizar existente en lugar de destruir
        local label = existing:FindFirstChild("Label")
        if label then
            label.Text = text
            label.TextColor3 = color3
        end
        existing.Enabled = true
        return existing
    end
    
    -- Crear nuevo
    local g = Instance.new("BillboardGui")
    g.Name = "ESP_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 200, 0, 36)
    g.StudsOffset = Vector3.new(0, 3, 0)
    g.Enabled = true
    g.Parent = parent
    
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1, 1, 1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0, 0, 0)
    l.Parent = g
    
    -- Registrar para limpieza
    table.insert(espObjects, g)
    
    return g
end

-- Highlight optimizado
local function ensureHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    local hl = model:FindFirstChild("ESP_Highlight")
    if not hl then
        local success, result = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "ESP_Highlight"
            h.Adornee = model
            h.FillTransparency = 0.5
            h.OutlineTransparency = 0.2
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.FillColor = color
            h.OutlineColor = color
            h.Parent = model
            return h
        end)
        if success then 
            hl = result
            table.insert(espObjects, hl)
        else 
            return nil 
        end
    else
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.5
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
    end
    return hl
end

local function clearHighlight(model)
    if model and model:FindFirstChild("ESP_Highlight") then
        local hl = model.ESP_Highlight
        hl:Destroy()
        -- Remover de la lista
        for i, obj in ipairs(espObjects) do
            if obj == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

-- Función para obtener rol MEJORADA
local function getRole(p)
    if not p then return "Lobby" end
    local team = p.Team
    if not team then return "Lobby" end
    local teamName = team.Name:lower()
    if teamName:find("killer") then
        return "Killer"
    elseif teamName:find("survivor") then
        return "Survivor"
    end
    return "Lobby"
end

-- Función para verificar espectador MEJORADA
local function isSpectator(p)
    if not p then return true end
    if not p.Character then return true end
    
    local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return true end
    
    return p:GetAttribute("Spectator") == true
end

-- Función para determinar si está en lobby
local function isInLobby(p)
    if not p then return true end
    if not p.Character then return true end
    
    -- Verificar si está en un área de lobby
    local hrp = p.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local pos = hrp.Position
        if pos.Y < -100 then
            return true
        end
    end
    
    return getRole(p) == "Lobby"
end

-- Función para obtener color MEJORADA
local function getPlayerColor(p)
    if isInLobby(p) then
        return lobbyColor
    elseif isSpectator(p) then
        return spectatorColor
    elseif getRole(p) == "Killer" then
        return killerColor
    else
      return survivorColor
    end
end

-- Crear ventana principal
local Window = Rayfield:CreateWindow({
    Name = "LoreOnTop",
    LoadingTitle = "Violence District",
    LoadingSubtitle = "Hecho por kcha abuelas3000",
    ConfigurationSaving = {Enabled = true, FolderName = "ESP_Suite", FileName = "esp_config"},
    KeySystem = false
})

-- VISUAL TAB
local VisualTab = Window:CreateTab("Visual")
VisualTab:CreateSection("ESP")

-- Función para limpiar ESP de un jugador
local function cleanPlayerESP(p)
    if not p then return end
    
    if p.Character then
        clearHighlight(p.Character)
        local head = p.Character:FindFirstChild("Head")
        if head and head:FindFirstChild("ESP_Tag") then
            head.ESP_Tag:Destroy()
        end
    end
    
    if playerCache[p] then
        playerCache[p] = nil
    end
end

-- Aplicar ESP a un jugador (MEJORADA)
local function applyOnePlayerESP(p)
    if p == LP then return end
    
    local character = p.Character
    if not (character and alive(character)) then
        cleanPlayerESP(p)
        return
    end
    
    -- Obtener color
    local color = getPlayerColor(p)
    
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    
    -- Aplicar ESP
    if playerESPEnabled or nametagsEnabled then
        -- Highlight (solo si playerESPEnabled está activado)
        if playerESPEnabled then
            local hl = ensureHighlight(character, color)
            if hl then
                hl.Enabled = true
            end
        else
            -- Desactivar highlight si no está activado
            clearHighlight(character)
        end
        
        -- Nametag (solo si nametagsEnabled está activado)
        if nametagsEnabled and validPart(head) then
            local text = p.Name
            
            -- Añadir distancia si está habilitado
            if showDistance and not isSpectator(p) and not isInLobby(p) and hrp and LP.Character then
                local myHrp = LP.Character:FindFirstChild("HumanoidRootPart")
                if myHrp then
                    local distance = math.floor(dist(hrp.Position, myHrp.Position))
                    if distance <= maxDistance then
                        text = text .. " - " .. distance .. "m"
                    end
                end
            end
            
            -- Crear o actualizar nametag
            local tag = makeBillboard(text, color, head)
            if tag then
                tag.Enabled = true
            end
        elseif head and head:FindFirstChild("ESP_Tag") then
            -- Desactivar nametag si no está activado
            head.ESP_Tag.Enabled = false
        end
        
        -- Guardar en cache
        if not playerCache[p] then 
            playerCache[p] = {
                lastUpdate = tick(),
                character = character
            }
        end
        playerCache[p].lastUpdate = tick()
    else
        -- Limpiar todo si ambos están desactivados
        cleanPlayerESP(p)
    end
end

-- Loop de ESP MEJORADO
local espLoopConn = nil
local lastESPUpdate = 0
local ESP_UPDATE_INTERVAL = 0.1 -- Más rápido (100ms)

-- Sistema de actualización por lotes
local updateQueue = {}
local isProcessing = false

local function processUpdateQueue()
    if isProcessing then return end
    isProcessing = true
    
    -- Procesar máximo 5 jugadores por frame para mejor rendimiento
    local processed = 0
    local maxPerFrame = 5
    
    while #updateQueue > 0 and processed < maxPerFrame do
        local player = table.remove(updateQueue, 1)
        if player and player.Parent then
            applyOnePlayerESP(player)
            processed = processed + 1
        end
    end
    
    isProcessing = false
end

local function startESPLoop()
    if espLoopConn then 
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    espLoopConn = RunService.Heartbeat:Connect(function(deltaTime)
        if not (playerESPEnabled or nametagsEnabled) then return end
        
        -- Control de intervalo
        local now = tick()
        if now - lastESPUpdate < ESP_UPDATE_INTERVAL then 
            -- Procesar cola mientras espera
            processUpdateQueue()
            return 
        end
        lastESPUpdate = now
        
        -- Limpiar cola vieja
        updateQueue = {}
        
        -- Añadir todos los jugadores a la cola
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LP then
                table.insert(updateQueue, player)
            end
        end
        
        -- Procesar primer lote inmediatamente
        processUpdateQueue()
    end)
end

local function stopESPLoop()
    if espLoopConn then
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    -- Limpiar todo el ESP inmediatamente
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP then
            cleanPlayerESP(player)
        end
    end
    
    -- Limpiar objetos ESP residuales
    for _, obj in ipairs(espObjects) do
        if obj and obj.Parent then
            pcall(function() obj:Destroy() end)
        end
    end
    espObjects = {}
    playerCache = {}
    updateQueue = {}
end

-- Función para forzar actualización de todos los jugadores
local function forceUpdateAllPlayers()
    if not (playerESPEnabled or nametagsEnabled) then return end
    
    updateQueue = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP then
            table.insert(updateQueue, player)
            applyOnePlayerESP(player) -- Aplicar inmediatamente
        end
    end
end

-- Observadores de jugadores MEJORADOS
local function watchPlayer(p)
    if p == LP then return end
    if connections[p] then return end -- Ya está siendo observado
    
    local playerConns = {}
    
    -- Conectar eventos con respuesta inmediata
    table.insert(playerConns, p.CharacterAdded:Connect(function(character)
        task.wait(0.3) -- Menos espera
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end))
    
    table.insert(playerConns, p:GetPropertyChangedSignal("Team"):Connect(function()
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end))
    
    -- Conectar para cambios de atributos
    table.insert(playerConns, p:GetAttributeChangedSignal("Spectator"):Connect(function()
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end))
    
    -- Aplicar ESP inicial inmediatamente si tiene personaje
    if p.Character then
        task.spawn(function()
            task.wait(0.3)
            if playerESPEnabled or nametagsEnabled then
                applyOnePlayerESP(p)
            end
        end)
    end
    
    connections[p] = playerConns
end

local function unwatchPlayer(p)
    if connections[p] then
        for _, conn in ipairs(connections[p]) do
            pcall(function() conn:Disconnect() end)
        end
        connections[p] = nil
    end
    
    cleanPlayerESP(p)
    playerCache[p] = nil
end

-- Toggles Player ESP MEJORADOS
VisualTab:CreateToggle({
    Name = "Players ESP",
    CurrentValue = false,
    Flag = "PlayerESP",
    Callback = function(s)
        playerESPEnabled = s
        if s or nametagsEnabled then
            startESPLoop()
            task.wait(0.1)
            forceUpdateAllPlayers() -- Forzar actualización inmediata
        else
            stopESPLoop()
        end
    end
})

VisualTab:CreateToggle({
    Name = "Mostrar Nombres",
    CurrentValue = false,
    Flag = "Nametags",
    Callback = function(s)
        nametagsEnabled = s
        if s or playerESPEnabled then
            startESPLoop()
            task.wait(0.1)
            forceUpdateAllPlayers() -- Forzar actualización inmediata
        else
            stopESPLoop()
        end
    end
})

VisualTab:CreateToggle({
    Name = "Mostrar Distancia",
    CurrentValue = showDistance,
    Flag = "ShowDistance",
    Callback = function(s)
        showDistance = s
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers() -- Actualizar todos con nuevo formato
        end
    end
})

VisualTab:CreateButton({
    Name = "Forzar Actualización ESP",
    Callback = function()
        forceUpdateAllPlayers()
        Rayfield:Notify({
            Title = "ESP Actualizado",
            Content = "Todos los jugadores han sido actualizados",
            Duration = 2
        })
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Survivor",
    Color = survivorColor,
    Flag = "SurvivorCol",
    Callback = function(c) 
        survivorColor = c 
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Killer",
    Color = killerColor,
    Flag = "KillerCol",
    Callback = function(c) 
        killerColor = c 
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Lobby",
    Color = lobbyColor,
    Flag = "LobbyCol",
    Callback = function(c) 
        lobbyColor = c 
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateSlider({
    Name = "Distancia Máxima",
    Range = {50, 1000},
    Increment = 10,
    Suffix = " studs",
    CurrentValue = maxDistance,
    Flag = "MaxDistance",
    Callback = function(v)
        maxDistance = v
        if playerESPEnabled or nametagsEnabled then
            forceUpdateAllPlayers()
        end
    end
})

VisualTab:CreateSlider({
    Name = "Intervalo de Actualización",
    Range = {0.05, 0.5},
    Increment = 0.05,
    Suffix = " segundos",
    CurrentValue = ESP_UPDATE_INTERVAL,
    Flag = "UpdateInterval",
    Callback = function(v)
        ESP_UPDATE_INTERVAL = v
    end
})

-- Inicializar jugadores
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LP then
        watchPlayer(p)
    end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LP then
        watchPlayer(p)
        task.wait(0.5)
        if playerESPEnabled or nametagsEnabled then
            applyOnePlayerESP(p)
        end
    end
end)

Players.PlayerRemoving:Connect(function(p)
    unwatchPlayer(p)
end)

-- GENERATOR ESP (igual que el original pero funcional)
VisualTab:CreateSection("Generators")

local generatorESPEnabled = false
local generatorLoopConn = nil
local worldReg = {Generator = {}}

local function genProgress(m)
    local p = tonumber(m:GetAttribute("RepairProgress")) or 0
    if p <= 1.001 then p = p * 100 end
    return clamp(p, 0, 100)
end

local function ensureWorldEntry(cat, model)
    if not alive(model) or worldReg[cat][model] then return end
    local rep = firstBasePart(model)
    if not validPart(rep) then return end
    worldReg[cat][model] = {model = model, part = rep}
end

local function registerFromDescendant(obj)
    if not alive(obj) then return end
    if obj:IsA("Model") and obj.Name == "Generator" then
        ensureWorldEntry("Generator", obj)
    end
end

local function refreshRoots()
    local r1 = Workspace:FindFirstChild("Map")
    local r2 = Workspace:FindFirstChild("Map1")
    
    if r1 then
        for _, d in ipairs(r1:GetDescendants()) do 
            registerFromDescendant(d) 
        end
    end
    if r2 then
        for _, d in ipairs(r2:GetDescendants()) do 
            registerFromDescendant(d) 
        end
    end
end

local function colorFromProgress(t)
    t = clamp(t, 0, 1)
    local red = Color3.fromRGB(255, 0, 0)
    local yellow = Color3.fromRGB(255, 255, 0)
    local green = Color3.fromRGB(0, 255, 0)
    if t <= 0.5 then
        return red:Lerp(yellow, t / 0.5)
    else
        return yellow:Lerp(green, (t - 0.5) / 0.5)
    end
end

local function applyEnhancedGeneratorESP(entry)
    local model = entry.model
    local part = entry.part
    if not generatorESPEnabled or not alive(model) or not validPart(part) then return end

    local pct = genProgress(model)
    local t = clamp(pct / 100, 0, 1)

    local hlColor = (pct >= 100) and Color3.fromRGB(0, 255, 0) or generatorColor
    local hl = ensureHighlight(model, hlColor)
    if hl then
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
    end

    local textName = "VD_Text_Generator_Enhanced"
    local existing = part:FindFirstChild(textName)
    if existing then existing:Destroy() end
    
    local bb = makeBillboard("Gen " .. math.floor(pct + 0.5) .. "%", generatorColor, part)
    if bb then
        bb.Name = textName
        
        local lbl = bb:FindFirstChild("Label")
        if lbl then
            local progColor = colorFromProgress(t)
            lbl.TextColor3 = progColor
        end
    end
end

local function startGeneratorLoop()
    if generatorLoopConn then return end
    
    generatorLoopConn = RunService.Heartbeat:Connect(function()
        if not generatorESPEnabled then return end
        
        for _, entry in pairs(worldReg.Generator) do
            applyEnhancedGeneratorESP(entry)
        end
    end)
end

local function stopGeneratorLoop()
    if generatorLoopConn then
        generatorLoopConn:Disconnect()
        generatorLoopConn = nil
    end
    
    for _, entry in pairs(worldReg.Generator) do
        if entry.model then
            clearHighlight(entry.model)
            if entry.part and entry.part:FindFirstChild("VD_Text_Generator_Enhanced") then
                entry.part.VD_Text_Generator_Enhanced:Destroy()
            end
        end
    end
end

VisualTab:CreateToggle({
    Name = "Generator ESP",
    CurrentValue = false,
    Flag = "GeneratorESP",
    Callback = function(s)
        generatorESPEnabled = s
        if s then 
            startGeneratorLoop() 
        else 
            stopGeneratorLoop() 
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Generator Color",
    Color = generatorColor,
    Flag = "GenCol",
    Callback = function(c) 
        generatorColor = c 
    end
})

-- Buscar generadores al inicio
task.spawn(function()
    task.wait(3)
    refreshRoots()
end)

local SurvivorTab = Window:CreateTab("Survivors")
SurvivorTab:CreateSection("Generator Boost")

-- Variables
local genBoostEnabled = false
local genBoostMultiplier = 1.05
local repairWatcher = nil
local isRepairing = false
local originalValues = {}

-- Función para aplicar el boost
local function applyBoost()
    if not genBoostEnabled then return end
    
    local char = LP.Character
    if not char then return end
    
    -- Guardar valores originales la primera vez
    if not originalValues.repairboost then
        originalValues.repairboost = char:GetAttribute("repairboost") or 1.0
        originalValues.GroupProject = char:GetAttribute("GroupProject") or 0
        originalValues.gp_applied_by = char:GetAttribute("gp_applied_by") or 0
    end
    
    -- Aplicar nuevos valores
    pcall(function()
        char:SetAttribute("repairboost", 1.0 * genBoostMultiplier)
        char:SetAttribute("GroupProject", 2)
        char:SetAttribute("gp_applied_by", 2717078872)
    end)
end

-- Función para restaurar valores normales
local function restoreBoost()
    local char = LP.Character
    if not char then return end
    
    pcall(function()
        if originalValues.repairboost then
            char:SetAttribute("repairboost", originalValues.repairboost)
        else
            char:SetAttribute("repairboost", 1.0)
        end
        
        if originalValues.GroupProject then
            char:SetAttribute("GroupProject", originalValues.GroupProject)
        else
            char:SetAttribute("GroupProject", 0)
        end
        
        if originalValues.gp_applied_by then
            char:SetAttribute("gp_applied_by", originalValues.gp_applied_by)
        else
            char:SetAttribute("gp_applied_by", 0)
        end
    end)
end

-- Detectar si está cerca de generador
local function isNearGenerator()
    local char = LP.Character
    if not char then return false end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name:lower():find("generator") then
            local part = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                local distance = (hrp.Position - part.Position).Magnitude
                if distance < 15 then
                    return true
                end
            end
        end
    end
    
    return false
end

-- Sistema principal
local function startBoostWatcher()
    if repairWatcher then return end
    
    repairWatcher = RunService.Heartbeat:Connect(function()
        if not genBoostEnabled then return end
        
        local nearGenerator = isNearGenerator()
        
        if nearGenerator then
            if not isRepairing then
                applyBoost()
                isRepairing = true
            end
        else
            if isRepairing then
                restoreBoost()
                isRepairing = false
            end
        end
    end)
end

local function stopBoostWatcher()
    if repairWatcher then
        repairWatcher:Disconnect()
        repairWatcher = nil
    end
    
    restoreBoost()
    isRepairing = false
end

SurvivorTab:CreateToggle({
    Name = "Enable Generator Boost",
    CurrentValue = false,
    Flag = "GenBoostToggle",
    Callback = function(state)
        genBoostEnabled = state
        if state then
            startBoostWatcher()
        else
            stopBoostWatcher()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Repair Multiplier",
    Range = {1.00, 3.00},
    Increment = 0.05,
    Suffix = "x",
    CurrentValue = genBoostMultiplier,
    Flag = "GenBoostValue",
    Callback = function(value)
        genBoostMultiplier = value
        
        if genBoostEnabled and isRepairing then
            applyBoost()
        end
    end
})

SurvivorTab:CreateSection("Speed Boost")
local speedBoostEnabled = false
local speedBoostValue = 1.25

local function applySpeedBoost(char)
    if not speedBoostEnabled then return end
    if not char then return end

    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        pcall(function() hum.WalkSpeed = 16 * speedBoostValue end)
    end
end

local function removeSpeedBoost(char)
    if not char then return end

    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        pcall(function() hum.WalkSpeed = 16 end)
    end
end

LP.CharacterAdded:Connect(function(char)
    task.wait(0.2)
    if speedBoostEnabled then
        applySpeedBoost(char)
    end
end)

SurvivorTab:CreateToggle({
    Name = "Enable Speed Boost",
    CurrentValue = false,
    Flag = "SpeedBoostToggle",
    Callback = function(state)
        speedBoostEnabled = state
        local char = LP.Character

        if state then
            if char then applySpeedBoost(char) end
        else
            if char then removeSpeedBoost(char) end
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Speed Multiplier",
    Range = {1.00, 2.00},
    Increment = 0.10,
    Suffix = "x",
    CurrentValue = speedBoostValue,
    Flag = "SpeedBoostValue",
    Callback = function(v)
        speedBoostValue = v
        if speedBoostEnabled and LP.Character then
            applySpeedBoost(LP.Character)
        end
    end
})

-- SkillCheck Perfect
SurvivorTab:CreateSection("SkillCheck Gen")
local perfectEnabled = false
local perfectConn = nil

local function enablePerfectLoop()
    if perfectConn then return end
    
    perfectConn = RunService.Heartbeat:Connect(function()
        if not perfectEnabled then return end
        
        local pg = LP:FindFirstChild("PlayerGui")
        if not pg then return end

        for _, gui in ipairs(pg:GetChildren()) do
            local bar, zone, pointer = nil, nil, nil
            
            for _, obj in ipairs(gui:GetDescendants()) do
                if obj:IsA("Frame") or obj:IsA("ImageLabel") then
                    local size = obj.AbsoluteSize
                    
                    if size.X > 150 and size.Y < 80 and not bar then
                        bar = obj
                    end
                    
                    if bar and obj.Parent == bar and obj.AbsoluteSize.X > 0 and obj.AbsoluteSize.X < (bar.AbsoluteSize.X * 0.45) then
                        zone = obj
                    end
                    
                    if bar and obj.Parent == bar and obj.AbsoluteSize.X > 0 and obj.AbsoluteSize.X < math.max(8, bar.AbsoluteSize.X * 0.06) then
                        pointer = obj
                    end
                end
            end
            
            if bar and zone and pointer then
                local zoneCenter = zone.AbsolutePosition.X + (zone.AbsoluteSize.X / 2)
                local barStart = bar.AbsolutePosition.X
                local barWidth = bar.AbsoluteSize.X
                
                if barWidth > 0 then
                    local perc = (zoneCenter - barStart) / barWidth
                    perc = clamp(perc, 0, 1)
                    
                    pcall(function()
                        if typeof(pointer.Position) == "UDim2" then
                            pointer.Position = UDim2.new(perc, 0, pointer.Position.Y.Scale, pointer.Position.Y.Offset)
                        elseif pointer.Value ~= nil then
                            pointer.Value = perc
                        end
                    end)
                end
            end
        end
    end)
end

local function disablePerfectLoop()
    if perfectConn then
        perfectConn:Disconnect()
        perfectConn = nil
    end
end

SurvivorTab:CreateToggle({
    Name = "Enable Perfect Skillcheck Gen",
    CurrentValue = false,
    Callback = function(v)
        perfectEnabled = v
        if v then enablePerfectLoop() else disablePerfectLoop() end
    end
})

-- No SkillCheck
SurvivorTab:CreateSection("No SkillCheck Gen")
local noSkillEnabled = false
local noSkillDescConn = nil

local function isSkillObject(obj)
    if not obj or not obj.Name then return false end
    local n = obj.Name:lower()
    return n:find("skill") or n:find("check") or n:find("skillcheck")
end

local function startNoSkill()
    if noSkillEnabled then return end
    noSkillEnabled = true

    local pg = LP:FindFirstChild("PlayerGui")
    if pg then
        for _, d in ipairs(pg:GetDescendants()) do
            if isSkillObject(d) then 
                pcall(function() d:Destroy() end)
            end
        end

        if noSkillDescConn then noSkillDescConn:Disconnect() end
        noSkillDescConn = pg.DescendantAdded:Connect(function(d)
            if noSkillEnabled and isSkillObject(d) then 
                pcall(function() d:Destroy() end)
            end
        end)
    end
end

local function stopNoSkill()
    noSkillEnabled = false
    if noSkillDescConn then
        noSkillDescConn:Disconnect()
        noSkillDescConn = nil
    end
end

SurvivorTab:CreateToggle({
    Name = "Enable No Skillchecks Gen",
    CurrentValue = false,
    Callback = function(v)
        if v then startNoSkill() else stopNoSkill() end
    end
})

-- KILLERS TAB
local KillerTab = Window:CreateTab("Killers")
KillerTab:CreateSection("Speed Boost (Killer)")

local killerSpeedEnabled = false
local killerSpeedValue = 1.3

KillerTab:CreateToggle({
    Name = "Killer Speed Boost",
    CurrentValue = false,
    Callback = function(v)
        killerSpeedEnabled = v
        local char = LP.Character
        if char then
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                if v then
                    pcall(function() humanoid.WalkSpeed = 16 * killerSpeedValue end)
                else
                    pcall(function() humanoid.WalkSpeed = 16 end)
                end
            end
        end
    end
})

KillerTab:CreateSlider({
    Name = "Killer Speed Multiplier",
    Range = {1.0, 2.0},
    Increment = 0.1,
    CurrentValue = killerSpeedValue,
    Callback = function(v)
        killerSpeedValue = v
        if killerSpeedEnabled and LP.Character then
            local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                pcall(function() humanoid.WalkSpeed = 16 * killerSpeedValue end)
            end
        end
    end
})

-- GRAPHICS TAB
local GraphicsTab = Window:CreateTab("Graphics")
GraphicsTab:CreateSection("Optimization")

-- No Fog
local nfActive = false
local nfStore = {conns = {}, tick = nil}
local nfQueue, nfQueued = {}, {}

local function nfNameHasFog(inst)
    local n = inst and inst.Name or ""
    n = string.lower(n)
    return string.find(n, "fog", 1, true) ~= nil
end

local function nfHardNuke(o)
    pcall(function()
        if o:IsA("ParticleEmitter") then 
            o.Enabled = false 
            o.Rate = 0 
        end
        o:Destroy()
    end)
end

local function nfIsCandidate(inst)
    if not inst or not inst.Parent then return false end
    if nfNameHasFog(inst) then return true end
    if inst:IsA("Clouds") or inst:IsA("Atmosphere") then return true end
    if inst:IsA("ParticleEmitter") then return true end
    if inst:IsA("SunRaysEffect") or inst:IsA("BloomEffect") or inst:IsA("DepthOfFieldEffect") then return true end
    return false
end

local function nfHandle(inst)
    if not inst or not inst.Parent then return end
    if nfNameHasFog(inst) or inst:IsA("Clouds") or inst:IsA("Atmosphere") or inst:IsA("ParticleEmitter") then
        nfHardNuke(inst)
        return
    end
    if inst:IsA("SunRaysEffect") or inst:IsA("BloomEffect") or inst:IsA("DepthOfFieldEffect") then
        nfHardNuke(inst)
        return
    end
end

local function nfEnqueueOne(inst)
    if not nfActive or not nfIsCandidate(inst) or nfQueued[inst] then return end
    nfQueued[inst] = true
    table.insert(nfQueue, inst)
end

local function nfBindWatchers()
    local c1 = Workspace.DescendantAdded:Connect(function(d) nfEnqueueOne(d) end)
    local c2 = Lighting.DescendantAdded:Connect(function(d) nfEnqueueOne(d) end)
    local c3 = ReplicatedStorage.DescendantAdded:Connect(function(d) nfEnqueueOne(d) end)
    table.insert(nfStore.conns, c1)
    table.insert(nfStore.conns, c2)
    table.insert(nfStore.conns, c3)
end

local function nfStartQueue()
    if nfStore.tick then nfStore.tick:Disconnect() nfStore.tick = nil end
    nfStore.tick = RunService.Heartbeat:Connect(function()
        if not nfActive then return end
        local t0 = os.clock()
        while #nfQueue > 0 and (os.clock() - t0) < 0.004 do
            local inst = table.remove(nfQueue, 1)
            if inst and inst.Parent then nfHandle(inst) end
        end
    end)
end

local function nfInitialSweep()
    for _, root in ipairs({Workspace, Lighting, ReplicatedStorage}) do
        for _, d in ipairs(root:GetDescendants()) do
            if nfIsCandidate(d) then nfHandle(d) end
        end
    end
end

local function nfEnable()
    if nfActive then return end
    nfActive = true
    nfInitialSweep()
    nfBindWatchers()
    nfStartQueue()
end

local function nfDisable()
    if not nfActive then return end
    nfActive = false
    if nfStore.tick then pcall(function() nfStore.tick:Disconnect() end) nfStore.tick = nil end
    for _, c in ipairs(nfStore.conns) do pcall(function() c:Disconnect() end) end
    nfStore.conns = {}
    nfQueue, nfQueued = {}, {}
end

GraphicsTab:CreateToggle({
    Name = "No Fog",
    CurrentValue = false,
    Flag = "NoFog",
    Callback = function(s) 
        if s then nfEnable() else nfDisable() end
    end
})

-- No Shadows
local nsActive = false
local nsStore = {lighting = {}, parts = {}, conns = {}}
local nsQueue, nsQueued, nsProcessed = {}, {}, {}

local function nsEnable()
    if nsActive then return end
    nsActive = true
    
    pcall(function()
        Lighting.GlobalShadows = false
    end)
    
    for _, part in ipairs(Workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            nsStore.parts[part] = part.CastShadow
            pcall(function() part.CastShadow = false end)
        end
    end
end

local function nsDisable()
    if not nsActive then return end
    nsActive = false
    
    pcall(function()
        Lighting.GlobalShadows = true
    end)
    
    for part, value in pairs(nsStore.parts) do
        if part and part.Parent then
            pcall(function() part.CastShadow = value end)
        end
    end
    nsStore.parts = {}
end

GraphicsTab:CreateToggle({
    Name = "No Shadows",
    CurrentValue = false,
    Flag = "NoShadows",
    Callback = function(s) 
        if s then nsEnable() else nsDisable() end
    end
})

-- MISCELLANEOUS
local MiscTab = Window:CreateTab("Misc")
MiscTab:CreateSection("Utilities")

local autoRespawnEnabled = false
MiscTab:CreateToggle({
    Name = "Auto Respawn",
    CurrentValue = false,
    Callback = function(v)
        autoRespawnEnabled = v
    end
})

-- Cleanup function
local function cleanup()
    -- Detener todos los loops
    if espLoopConn then espLoopConn:Disconnect() end
    if generatorLoopConn then generatorLoopConn:Disconnect() end
    if repairWatcher then repairWatcher:Disconnect() end  -- CORREGIDO: era repairConnection
    if perfectConn then perfectConn:Disconnect() end
    
    -- Limpiar ESP
    stopESPLoop()
    stopGeneratorLoop()
    stopBoostWatcher()  -- CORREGIDO: era stopRepairWatcher
    
    -- Limpiar No Fog/Shadows
    nfDisable()
    nsDisable()
    
    -- Restaurar velocidad
    local char = LP.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            pcall(function() humanoid.WalkSpeed = 16 end)
        end
    end
end

-- Conectar cleanup
game:GetService("UserInputService").WindowFocusReleased:Connect(cleanup)

-- Cargar configuración y notificar
Rayfield:LoadConfiguration()
Rayfield:Notify({
    Title = "LoreOnTop",
    Content = "Script loaded",
    Duration = 5,
    Image = "rbxassetid://4483345998"
})
