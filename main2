local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Servicios de Roblox
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local LP = Players.LocalPlayer

-- Funciones auxiliares
local function alive(i)
    if not i then return false end
    local ok = pcall(function() return i.Parent end)
    return ok and i.Parent ~= nil
end

local function validPart(p) return p and alive(p) and p:IsA("BasePart") end
local function clamp(n, lo, hi) if n < lo then return lo elseif n > hi then return hi else return n end end
local function dist(a, b) return (a - b).Magnitude end

local function firstBasePart(inst)
    if not alive(inst) then return nil end
    if inst:IsA("BasePart") then return inst end
    if inst:IsA("Model") then
        if inst.PrimaryPart and inst.PrimaryPart:IsA("BasePart") and alive(inst.PrimaryPart) then return inst.PrimaryPart end
        local p = inst:FindFirstChildWhichIsA("BasePart", true)
        if validPart(p) then return p end
    end
    if inst:IsA("Tool") then
        local h = inst:FindFirstChild("Handle") or inst:FindFirstChildWhichIsA("BasePart")
        if validPart(h) then return h end
    end
    return nil
end

local function makeBillboard(text, color3)
    local g = Instance.new("BillboardGui")
    g.Name = "VD_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 200, 0, 36)
    g.StudsOffset = Vector3.new(0, 3, 0)
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1, 1, 1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0, 0, 0)
    l.Parent = g
    return g
end

local function clearChild(o, n)
    if o and alive(o) then
        local c = o:FindFirstChild(n)
        if c then pcall(function() c:Destroy() end) end
    end
end

local function ensureHighlight(model, fill)
    if not (model and model:IsA("Model") and alive(model)) then return end
    local hl = model:FindFirstChild("VD_HL")
    if not hl then
        local ok, obj = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "VD_HL"
            h.Adornee = model
            h.FillTransparency = 0.5
            h.OutlineTransparency = 0
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.Parent = model
            return h
        end)
        if ok then hl = obj else return end
    end
    hl.FillColor = fill
    hl.OutlineColor = fill
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    return hl
end

local function clearHighlight(model)
    if model and model:FindFirstChild("VD_HL") then
        pcall(function() model.VD_HL:Destroy() end)
    end
end

-- Crear ventana
local Window = Rayfield:CreateWindow({
    Name = "LoreOnTop",
    LoadingTitle = "Violence District",
    LoadingSubtitle = "by Lore",
    ConfigurationSaving = {Enabled = true, FolderName = "ESP_Suite", FileName = "esp_config"},
    KeySystem = false
})

-- VISUAL TAB
local VisualTab = Window:CreateTab("Visual")
VisualTab:CreateSection("ESP")

local function getRole(p)
    local tn = p.Team and p.Team.Name and p.Team.Name:lower() or ""
    if tn:find("killer") then return "Killer" end
    if tn:find("survivor") then return "Survivor" end
    return "Survivor"
end

-- Variables Player ESP
local survivorColor = Color3.fromRGB(0, 255, 0)
local killerColor = Color3.fromRGB(255, 0, 0)
local spectatorColor = Color3.fromRGB(255, 255, 255)

local playerESPEnabled = false
local nametagsEnabled = false
local showDistance = true
local maxDistance = 500
local highlightFillTransparency = 0.5
local highlightOutlineTransparency = 0.0
local textTransparency = 0.0
local playerConns = {}
local espLoopConn = nil

-- Detectar si está espectando
local function isSpectating(p)
    -- No tiene character → espectador
    if not p.Character then return true end

    -- Humanoid muerto → espectador
    local hum = p.Character:FindFirstChildWhichIsA("Humanoid")
    if hum and hum.Health <= 0 then return true end

    -- Atributo opcional del juego
    if p:GetAttribute("Spectating") == true then return true end

    return false
end

-- Aplicar ESP a un player
local function applyOnePlayerESP(p)
    if p == LP then return end
    local c = p.Character
    if not (c and alive(c)) then return end

    -- Color según sea killer, survivor o espectador
    local col
    if isSpectating(p) then
        col = spectatorColor
    else
        local role = getRole(p)
        col = (role == "Killer") and killerColor or survivorColor
    end

    local head = c:FindFirstChild("Head")
    local hrp = c:FindFirstChild("HumanoidRootPart")

    if playerESPEnabled then
        -- Highlight
        local hl = ensureHighlight(c, col)
        if hl then
            hl.FillTransparency = highlightFillTransparency
            hl.OutlineTransparency = highlightOutlineTransparency
        end

        -- Nametag
        if nametagsEnabled and validPart(head) then
            local tag = head:FindFirstChild("VD_Tag") or makeBillboard("", col)
            tag.Name = "VD_Tag"
            tag.Parent = head

            local l = tag:FindFirstChild("Label")
            if l then
                local text = p.Name

                -- Distancia SOLO si no es espectador
                if showDistance
                    and not isSpectating(p)
                    and hrp
                    and LP.Character
                    and LP.Character:FindFirstChild("HumanoidRootPart")
                then
                    local d = math.floor(dist(hrp.Position, LP.Character.HumanoidRootPart.Position))
                    text = text .. " - " .. d .. "m"
                end

                l.Text = text
                l.TextColor3 = col
                l.TextTransparency = textTransparency
                l.TextStrokeTransparency = textTransparency
            end
        else
            local t = head and head:FindFirstChild("VD_Tag")
            if t then pcall(function() t:Destroy() end) end
        end
    else
        -- ESP apagado → limpiar todo
        clearHighlight(c)
        local t = head and head:FindFirstChild("VD_Tag")
        if t then pcall(function() t:Destroy() end) end
    end
end

-- ESP Loop
local function startESPLoop()
    if espLoopConn then return end
    espLoopConn = RunService.Heartbeat:Connect(function()
        if not playerESPEnabled and not nametagsEnabled then return end
        for _, pl in ipairs(Players:GetPlayers()) do
            if pl ~= LP then applyOnePlayerESP(pl) end
        end
    end)
end

local function stopESPLoop()
    if espLoopConn then espLoopConn:Disconnect() espLoopConn = nil end
end

-- Watch players
local function watchPlayer(p)
    if playerConns[p] then
        for _, cn in ipairs(playerConns[p]) do
            cn:Disconnect()
        end
    end

    playerConns[p] = {}

    table.insert(playerConns[p], p.CharacterAdded:Connect(function()
        task.delay(0.15, function()
            applyOnePlayerESP(p)
        end)
    end))

    table.insert(playerConns[p], p:GetPropertyChangedSignal("Team"):Connect(function()
        applyOnePlayerESP(p)
    end))

    if p.Character then applyOnePlayerESP(p) end
end

local function unwatchPlayer(p)
    if p.Character then
        clearHighlight(p.Character)
        local head = p.Character:FindFirstChild("Head")
        if head and head:FindFirstChild("VD_Tag") then
            pcall(function() head.VD_Tag:Destroy() end)
        end
    end

    if playerConns[p] then
        for _, cn in ipairs(playerConns[p]) do
            cn:Disconnect()
        end
    end

    playerConns[p] = nil
end

-- Toggles Player ESP
VisualTab:CreateToggle({
    Name = "Players ESP",
    CurrentValue = false,
    Flag = "PlayerESP",
    Callback = function(s)
        playerESPEnabled = s
        if playerESPEnabled or nametagsEnabled then startESPLoop() else stopESPLoop() end
    end
})

VisualTab:CreateToggle({
    Name = "Names/Distance",
    CurrentValue = false,
    Flag = "Nametags",
    Callback = function(s)
        nametagsEnabled = s
        if playerESPEnabled or nametagsEnabled then startESPLoop() else stopESPLoop() end
    end
})

VisualTab:CreateColorPicker({
    Name = "Survivor Color",
    Color = survivorColor,
    Flag = "SurvivorCol",
    Callback = function(c) survivorColor = c end
})

VisualTab:CreateColorPicker({
    Name = "Killer Color",
    Color = killerColor,
    Flag = "KillerCol",
    Callback = function(c) killerColor = c end
})

VisualTab:CreateSlider({
    Name = "Player Transparency",
    Range = {0, 1},
    Increment = 0.1,
    CurrentValue = 0.5,
    Flag = "FillTrans",
    Callback = function(v) highlightFillTransparency = v end
})

VisualTab:CreateSlider({
    Name = "Outline Transparency",
    Range = {0, 1},
    Increment = 0.1,
    CurrentValue = 0.0,
    Flag = "OutlineTrans",
    Callback = function(v) highlightOutlineTransparency = v end
})

VisualTab:CreateSlider({
    Name = "Text Transparency",
    Range = {0, 1},
    Increment = 0.1,
    CurrentValue = 0.0,
    Flag = "TextTrans",
    Callback = function(v) textTransparency = v end
})

-- Inicializar players
for _, p in ipairs(Players:GetPlayers()) do if p ~= LP then watchPlayer(p) end end
Players.PlayerAdded:Connect(watchPlayer)
Players.PlayerRemoving:Connect(unwatchPlayer)

-- GENERATOR ESP
VisualTab:CreateSection("Generators")

local generatorESPEnabled = false
local generatorColor = Color3.fromRGB(0, 170, 255)
local generatorTextPrefix = "Gen"
local worldReg = {Generator = {}}
local mapAdd, mapRem = {}, {}

local function genProgress(m)
    local p = tonumber(m:GetAttribute("RepairProgress")) or 0
    if p <= 1.001 then p = p * 100 end
    return clamp(p, 0, 100)
end

local function ensureWorldEntry(cat, model)
    if not alive(model) or worldReg[cat][model] then return end
    local rep = firstBasePart(model)
    if not validPart(rep) then return end
    worldReg[cat][model] = {model = model, part = rep}
end

local function registerFromDescendant(obj)
    if not alive(obj) then return end
    if obj:IsA("Model") and obj.Name == "Generator" then
        ensureWorldEntry("Generator", obj)
    end
end

local function refreshRoots()
    for _, cn in pairs(mapAdd) do if cn then cn:Disconnect() end end
    for _, cn in pairs(mapRem) do if cn then cn:Disconnect() end end
    mapAdd, mapRem = {}, {}
    local r1 = Workspace:FindFirstChild("Map")
    local r2 = Workspace:FindFirstChild("Map1")
    if r1 then
        mapAdd[r1] = r1.DescendantAdded:Connect(registerFromDescendant)
        for _, d in ipairs(r1:GetDescendants()) do registerFromDescendant(d) end
    end
    if r2 then
        mapAdd[r2] = r2.DescendantAdded:Connect(registerFromDescendant)
        for _, d in ipairs(r2:GetDescendants()) do registerFromDescendant(d) end
    end
end

local function applyEnhancedGeneratorESP(entry)
    local model = entry.model
    local part = entry.part
    if not generatorESPEnabled or not alive(model) or not validPart(part) then return end

    local pct = genProgress(model)
    local dynamicCol = (pct >= 100) and Color3.fromRGB(0, 255, 0) or generatorColor

    local hl = ensureHighlight(model, dynamicCol)
    if hl then
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0.2
    end

    local textName = "VD_Text_Generator_Enhanced"
    local bb = part:FindFirstChild(textName)
    if not bb then
        bb = makeBillboard("", dynamicCol)
        bb.Name = textName
        bb.Parent = part
    end

    local lbl = bb:FindFirstChild("Label")
    if lbl then
        lbl.Text = generatorTextPrefix .. math.floor(pct + 0.5) .. "%"
        lbl.TextColor3 = dynamicCol
        lbl.TextTransparency = 0.7
        lbl.TextStrokeTransparency = 0.2
    end
end

local generatorEnhancedLoopConn = nil
local function startGeneratorEnhancedLoop()
    if generatorEnhancedLoopConn then return end
    generatorEnhancedLoopConn = RunService.Heartbeat:Connect(function()
        if not generatorESPEnabled then return end
        for _, entry in pairs(worldReg.Generator) do
            applyEnhancedGeneratorESP(entry)
        end
    end)
end

local function stopGeneratorEnhancedLoop()
    if generatorEnhancedLoopConn then
        generatorEnhancedLoopConn:Disconnect()
        generatorEnhancedLoopConn = nil
    end
    for _, entry in pairs(worldReg.Generator) do
        if entry.model then
            clearHighlight(entry.model)
            clearChild(entry.part, "VD_Text_Generator_Enhanced")
        end
    end
end

VisualTab:CreateToggle({
    Name = "Generator ESP",
    CurrentValue = false,
    Flag = "GeneratorESP",
    Callback = function(s)
        generatorESPEnabled = s
        if s then startGeneratorEnhancedLoop() else stopGeneratorEnhancedLoop() end
    end
})

VisualTab:CreateColorPicker({
    Name = "Generator Color",
    Color = generatorColor,
    Flag = "GenCol",
    Callback = function(c) generatorColor = c end
})

refreshRoots()

-- SURVIVORS & KILLERS
local SurvivorTab = Window:CreateTab("Survivors")
SurvivorTab:CreateSection("Generators")

local KillerTab = Window:CreateTab("Killers")
KillerTab:CreateSection("Survivors")

-- GRAPHICS TAB
local GraphicsTab = Window:CreateTab("Graphics")
GraphicsTab:CreateSection("Optimization")

-- Sección No Fog
local nfActive = false
local nfStore = {conns = {}, tick = nil}
local nfQueue, nfQueued = {}, setmetatable({}, {__mode = "k"})

local function nfNameHasFog(inst)
    local n = inst and inst.Name or ""
    n = string.lower(n)
    return string.find(n, "fog", 1, true) ~= nil
end

local function nfHardNuke(o)
    pcall(function()
        for _, d in ipairs(o:GetDescendants()) do
            if d:IsA("ParticleEmitter") then pcall(function() d.Enabled = false d.Rate = 0 end) end
        end
        o:Destroy()
    end)
end

local function nfIsCandidate(inst)
    if not inst or not inst.Parent then return false end
    if nfNameHasFog(inst) then return true end
    if inst:IsA("Clouds") or inst:IsA("Atmosphere") then return true end
    if inst:IsA("ParticleEmitter") then return true end
    if inst:IsA("SunRaysEffect") or inst:IsA("BloomEffect") or inst:IsA("DepthOfFieldEffect") then return true end
    return false
end

local function nfHandle(inst)
    if not inst or not inst.Parent then return end
    if nfNameHasFog(inst) then
        nfHardNuke(inst)
        return
    end
    if inst:IsA("Clouds") or inst:IsA("Atmosphere") then
        nfHardNuke(inst)
        return
    end
    if inst:IsA("ParticleEmitter") then
        nfHardNuke(inst)
        return
    end
    if inst:IsA("SunRaysEffect") or inst:IsA("BloomEffect") or inst:IsA("DepthOfFieldEffect") then
        nfHardNuke(inst)
        return
    end
    for _, d in ipairs(inst:GetDescendants()) do
        if nfNameHasFog(d) or d:IsA("ParticleEmitter") then nfHardNuke(d) end
    end
end

local function nfEnqueueOne(inst)
    if not nfActive or not nfIsCandidate(inst) or nfQueued[inst] then return end
    nfQueued[inst] = true
    table.insert(nfQueue, inst)
end

local function nfBindWatchers()
    local c1 = Workspace.DescendantAdded:Connect(function(d) nfEnqueueOne(d) end)
    local c2 = Lighting.DescendantAdded:Connect(function(d) nfEnqueueOne(d) end)
    local c3 = ReplicatedStorage.DescendantAdded:Connect(function(d) nfEnqueueOne(d) end)
    table.insert(nfStore.conns, c1)
    table.insert(nfStore.conns, c2)
    table.insert(nfStore.conns, c3)
end

local function nfStartQueue()
    if nfStore.tick then nfStore.tick:Disconnect() nfStore.tick = nil end
    nfStore.tick = RunService.Heartbeat:Connect(function()
        if not nfActive then return end
        local t0 = os.clock()
        while #nfQueue > 0 and (os.clock() - t0) < 0.004 do
            local inst = table.remove(nfQueue, 1)
            if inst and inst.Parent then nfHandle(inst) end
        end
    end)
end

local function nfInitialSweep()
    for _, root in ipairs({Workspace, Lighting, ReplicatedStorage}) do
        for _, d in ipairs(root:GetDescendants()) do
            if nfIsCandidate(d) then nfHandle(d) end
        end
    end
end

local function nfEnable()
    if nfActive then return end
    nfActive = true
    nfInitialSweep()
    nfBindWatchers()
    nfStartQueue()
end

local function nfDisable()
    if not nfActive then return end
    nfActive = false
    if nfStore.tick then pcall(function() nfStore.tick:Disconnect() end) nfStore.tick = nil end
    for _, c in ipairs(nfStore.conns) do pcall(function() c:Disconnect() end) end
    nfStore.conns = {}
    nfQueue, nfQueued = {}, setmetatable({}, {__mode = "k"})
end

GraphicsTab:CreateToggle({
    Name = "No Fog",
    CurrentValue = false,
    Flag = "NoFog",
    Callback = function(s) if s then nfEnable() else nfDisable() end end
})

-- Sección No Shadows
local nsActive = false
local nsStore = {lighting = {}, parts = setmetatable({}, {__mode = "k"}), conns = {}}
local nsQueue, nsQueued, nsProcessed = {}, setmetatable({}, {__mode = "k"}), setmetatable({}, {__mode = "k"})
local nsSignal = Instance.new("BindableEvent")
local nsBatchSize, nsTickDelay = 400, 0.02

local function nsSaveLighting()
    nsStore.lighting = {GlobalShadows = Lighting.GlobalShadows, Technology = Lighting.Technology}
end

local function nsApplyLighting()
    pcall(function()
        Lighting.GlobalShadows = false
        Lighting.Technology = Enum.Technology.Compatibility
    end)
end

local function nsRestoreLighting()
    for k, v in pairs(nsStore.lighting or {}) do pcall(function() if v ~= nil then Lighting[k] = v end end) end
end

local function nsIsCandidate(o) return o and o:IsA("BasePart") end

local function nsSavePart(p) if nsStore.parts[p] == nil then nsStore.parts[p] = {CastShadow = p.CastShadow} end end

local function nsHandlePart(p) if nsProcessed[p] then return end nsProcessed[p] = true nsSavePart(p) pcall(function() p.CastShadow = false end) end

local function nsEnqueue(o) if nsActive and nsIsCandidate(o) and not nsQueued[o] then nsQueued[o] = true table.insert(nsQueue, o) nsSignal:Fire() end end

local function nsProcessQueue()
    while nsActive do
        if #nsQueue == 0 then nsSignal.Event:Wait() end
        local c = 0
        while nsActive and #nsQueue > 0 and c < nsBatchSize do
            local o = table.remove(nsQueue, 1)
            if o and o.Parent then nsHandlePart(o) end
            c = c + 1
        end
        task.wait(nsTickDelay)
    end
end

local function nsSoftRescan()
    for _, root in ipairs({Workspace, Workspace:FindFirstChild("Map"), Workspace:FindFirstChild("Terrain")}) do
        if root then for _, d in ipairs(root:GetDescendants()) do if nsIsCandidate(d) then nsEnqueue(d) end end end
    end
end

local function nsBindWatchers()
    local a = Workspace.DescendantAdded:Connect(function(d) if nsIsCandidate(d) then nsEnqueue(d) end end)
    local b = Workspace.ChildAdded:Connect(function(ch) if ch.Name == "Map" or ch.Name == "Map1" then task.delay(0.2, nsSoftRescan) end end)
    local c = RunService.Heartbeat:Connect(function()
        local t = os.clock()
        if t - nsLastSoft >= nsSoftRescanInterval then nsLastSoft = t nsSoftRescan() end
    end)
    table.insert(nsStore.conns, a)
    table.insert(nsStore.conns, b)
    table.insert(nsStore.conns, c)
end

local nsThread = nil
local nsSoftRescanInterval, nsLastSoft = 6, 0

local function nsEnable()
    if nsActive then return end
    nsActive = true
    nsQueue, nsQueued, nsProcessed = {}, setmetatable({}, {__mode = "k"}), setmetatable({}, {__mode = "k"})
    nsSaveLighting()
    nsApplyLighting()
    nsSoftRescan()
    nsBindWatchers()
    if not nsThread then nsThread = task.spawn(nsProcessQueue) end
end

local function nsDisable()
    if not nsActive then return end
    nsActive = false
    for p, st in pairs(nsStore.parts) do if p and p.Parent and st and st.CastShadow ~= nil then pcall(function() p.CastShadow = st.CastShadow end) end end
    nsStore.parts = setmetatable({}, {__mode = "k"})
    for _, c in ipairs(nsStore.conns) do pcall(function() c:Disconnect() end) end
    nsStore.conns = {}
    nsRestoreLighting()
    nsQueue, nsQueued, nsProcessed = {}, setmetatable({}, {__mode = "k"}), setmetatable({}, {__mode = "k"})
    nsSignal:Fire()
    nsThread = nil
end

GraphicsTab:CreateToggle({
    Name = "No Shadows",
    CurrentValue = false,
    Flag = "NoShadows",
    Callback = function(s) if s then nsEnable() else nsDisable() end end
})

-- Cargar configuración y notificar
Rayfield:LoadConfiguration()
Rayfield:Notify({Title = "LoreOnTop", Content = "Loaded", Duration = 6})
